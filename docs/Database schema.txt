Catenis app database schema:

// NOTE: there should be one and only one document (record) for the Catenis collection
Application {
  _id: [string], // MongoDB internal document ID provided by Meteor
  seedHmac: [string],  // Base-64 formatted HMAC-SHA256 signature of a predefined text using the application seed as the key. This is used to validate the application seed
  lastBlockHeight: [number],  // Height of last blockchain block that has already been processed by the application
  lastRetrievedOCMsgDataDate: [date/time]  // Date and time when Catenis off-chain message data (either envelope or receipt) has been last retrieved
}

BitcoinFees {
  _id: [string],  / MongoDB internal document ID provided by Meteor
  recommended: {
    fastestFee: [integer],
    halfHourFee: [integer],
    hourFee: [integer]
  }
  list: {
    fees: [{
      minFee: [integer],
      maxFee: [integer],
      minDelay: [integer],
      maxDelay: [integer],
      minMinutes: [integer],
      maxMinutes: [integer]
    }]
  },
  createdDate: [date/time] // Date and time when doc/rec has been created
}

BitcoinPrice {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  price: [numeric],  // Current bitcoin price expressed in USD
  referenceDate: [date/time],  // Date and time when price had been observed
  createdDate: [date/time]  // Date and time when doc/rec has been created
}

BcotPrice {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  price: [numeric],  // Current BCOT token price (as set by BCoT) expressed in USD
  createdDate: [date/time]  // Date and time when doc/rec has been created
}

IssuedBlockchainAddress {
  _id: [string], // MongoDB internal document ID provided by Meteor
  type: [string],  // Name of address type (HD node extended key type)
  parentPath: [string],  // Path of the HD node from which this address is derived
  path: [string],  // The HD node path which identifies this address
  addrIndex: [integer],  // The position occupied by this address within the range of addresses of that type
  btcAddressType: [string],  // Type of bitcoin address. Valid values (from BitcoinAddress.addressType): 'pubkeyhash', 'scripthash', 'witness_v0_keyhash', 'witness_v0_scripthash'
  addrHash: [string],  // Base-64 formatted SHA256 hash of blockchain address
  issuedDate: [date/time],  // Date and time when address has been issued (doc/rec created)
  expirationDate: [date/time],  // Date and time until when this address is considered to be valid to receive payments.
                                //  If set to null, address never expires; useful for unlocked Colored Coins issuing assets
  status: [string],  // Valid values: 'new' (from creation util expiration date), 'expired' (after expiration date while there are UTXOs associated with it), 'obsolete' (after expiration date if there are no UTXOs associated with it), 'nonexistent' (address for given index does not exist), 'discarded' (excluded from current available range of addresses of that type)
  lastStatusChangedDate: [date/time]  // Date and time when status has been last modified
}

IssuedOffChainAddress {
  _id: [string], // MongoDB internal document ID provided by Meteor
  type: [string],  // Name of address type (HD node extended key type)
  parentPath: [string],  // Path of the HD node from which this address is derived
  path: [string],  // The HD node path which identifies this address
  addrIndex: [integer],  // The position occupied by this address within the range of addresses of that type
  pubKeyHash: [string],  // Base-64 formatted HASH160 hash of the ECDSA public key that represents the off-chain address
  issuedDate: [date/time],  // Date and time when address has been issued (doc/rec created)
  isNonExistent: [boolean]  // Indicates that the address for the given index does not exist
}

License {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  level: [string],  // Name used to identify the license level
  order: [integer],  // The order associated with the license level. The lower the order, the less restrictive (e.g. maximum number of devices) the license is
  type: [string],  // Used to identify any characteristics that differentiate this specific license
  revision: [integer],  // The revision number of the license. Revisions are used to change some characteristics of a license (level & type) (e.g. maximum number of devices)
  maximumDevices: [integer],  // Maximum number of client devices that can be active at any time. If this field does not exist,
                              //  the license has no restriction for the number of devices
  validityMonths: [integer],  // Period of time, in months, through which this license is valid
  provisionalRenewalDays: [integer],  // The duration, in days, for the provisional renewal of this license. If this field does not exist,
                                      //  the license does not support provisional renewal
  status: [string],  // Indicates the current status of the license. Valid values (from License.status): 'new', 'active', 'inactive'
                     //  Note: only a single revision of a license (level & type) should be active at any time
  createdDate: [date/time],  // Date and time when doc/rec has been created
  activatedDate: [date/time],  // Date and time when license has benn activated
  deactivatedDate: [date/time]  // Date and time when license has been deactivated
}

ClientLicense {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  client_id: [string],  // MongoDB internal ID of Client doc/rec to which the license is assigned
  license_id: [string],  // MongoDB internal ID of License doc/rec assigned to the client
  validity: {
    startDate: [date/time],  // Date and time from when this license is valid
    endDate: [date/time]   // Date and time before when this license is still valid
  },
  provisionalRenewal: [boolean],  // Indicates whether this is a provisional renewal license
  observeProvisionalRenewal: [boolean],  // Indicates whether a provisional renewal license should be (automatically) created when this license expires, provided that the associated license supports it
                                         //  Note: this field does not apply and should not exist for provisional renewal licenses
  status: [string],  // The current status of the license. Valid values (from ClientLicense.status): 'provisioned', 'active', 'expired'.
                     //  Note: only a single license can be active at any time for a given client
  expireRemindNotifySent: [boolean],  // Indicates whether license expiration reminder e-mail notification has already been sent
  provisionedDate: [date/time],  // Date and time when license has been provisioned
  activatedDate: [date/time],  // Date and time when license has become active (status changed to active)
  expiredDate: [date/time]  // Date and time when license has become expired (status changed to expired)
}

CatenisNode {
  _id: [string], // MongoDB internal document ID provided by Meteor
  type: [string],  // Identifies the type of Catenis node. Valid values: 'hub' (Catenis Hub node; cntNodeIndex = 0), 'gateway' (Catenis Gateway node; cntNodeIndex >= 1)
  ctnNodeIndex: [integer],  // HD node index associated with this Catenis node
  props: {
    name: [string],  // Catenis node name
    description: [string],  // Brief description of Catenis node's purpose
    lastModifiedDate: [date/time]  // Date and time when one of the Catenis node's properties had been last modified
  },
  status: [string],  // Valid values: 'active' (Catenis node is in normal use mode); 'deleted' (Catenis node has been logically deleted)
  createdDate: [date/time],  // Date and time when doc/rec has been created
  lastStatusChangedDate: [date/time], // Date and time when status has been last changed
  deletedDate: [date/time]  // Date and time when doc/rec has been marked as logically deleted
}

Client {
  _id: [string], // MongoDB internal document ID provided by Meteor
  user_id: [string],  // MongoDB internal ID of User doc/rec with which this client is associated
  catenisNode_id: [string],  // MongoDB internal ID of CatenisNode doc/rec with which this client is associated
  clientId: [string],  // External ID used to uniquely identify this client
  index: {  // This composite field should be a unique ID
    ctnNodeIndex: [integer],  // HD node index associated with the Catenis node with which this client is associated
    clientIndex: [integer]  // HD node index associated with this client
  },
  props: {
    name: [string],  // Client name
    accountNumber: [String],  // Catenis generated code used to uniquely identify a Catenis client outside the system.
                              //  Format: E-00000000, where E is 'S' for sandbox, and 'P' for production
    lastModifiedDate: [date/time]  // Date and time when one of the client's properties had been last modified
  },
  apiAccessGenKey: [string],  // Key used to generate shared secret key used for client's devices to access the Catenis API
  timeZone: [string],  // The name of time zone (as defined by IANA, https://www.iana.org/time-zones) attributed to this client. This time zone is used amongst other things to determine the start and end date of licenses assigned to clients
  billingMode: [string],  // Identifies the billing mode used for this client. Valid values (from Client.billingMode): 'pre-paid', 'post-paid'
  status: [string],  // Valid values: 'new' (newly created client awaiting activation); 'active' (client is in normal use mode); 'deleted' (client has been logically deleted)
  createdDate: [date/time],  // Date and time when doc/rec has been created
  lastStatusChangedDate: [date/time], // Date and time when status has been last changed
  lastApiAccessGenKeyModifiedDate: [date/time], // date and time when API access generator key has been last modified
  _deleted: {  // Used to record the latest state of fields that are somehow changed once the doc/rec is marked as logically deleted. This field shall only exist while the doc/rec is logically deleted
    user_id: [string],  // The original field should be removed
    status: [string]  // The original field should have its value changed to 'deleted'
    deletedDate: [date/time]  // Date and time when doc/rec has been marked as logically deleted
  }
}

Device {
  _id: [string], // MongoDB internal document ID provided by Meteor
  client_id: [string],  // MongoDB internal ID of Client doc/rec with which this device is associated
  deviceId: [string],  // External ID used to uniquely identify this device
  index: {  // This composite field should be a unique ID
    ctnNodeIndex: [integer],  // HD node index associated with the Catenis node with which the client is associated
    clientIndex: [integer],  // HD node index associated with the client with which this device is associated
    deviceIndex: [integer]  // HD node index associated with this client's device 
  },
  props: {
    name: [string],  // Device name
    prodUniqueId: [string],  // Proprietary ID that uniquely identifies the client's physical device/product that is associated to this logical device
    public: [boolean],  // (optional) Indicates that the main properties of this device (name and prodUniqueId) can be disclosed
    lastModifiedDate: [date/time]  // Date and time when one of the device's properties had been last modified
  },
  apiAccessGenKey: [string],  // Key used to generate secret key used for accessing the Catenis API. If set to null, should use Client's default API access key
  status: [string],  // Valid values: 'new' (newly created device awaiting activation - funding of device's main/asset addresses have not started (due to lack of system funds)); 'pending' (awaiting confirmation of funding of device's main/asset addresses); 'active' (device in normal use mode - after device's main/asset addresses have been funded); 'inactive' (disabled device - device has been put temporarily out of use); 'deleted' (device has been logically deleted)
  createdDate: [date/time],  // Date and time when doc/rec was created
  lastStatusChangedDate: [date/time], // Date and time when status has been last changed
  lastApiAccessGenKeyModifiedDate: [date/time], // Date and time when API access generator key has been last modified
  _deleted: {  // Used to record the latest state of fields that are somehow changed once the doc/rec is marked as logically deleted. This field shall only exist while the doc/rec is logically deleted
    prodUniqueId: [string],  // The original field should be removed
    status: [string], // The original field should have its value changed to 'deleted'
    deletedDate: [date/time]  // Date and time when doc/rec has been marked as logically deleted
  }
}

Message {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  messageId: [string],  // External ID used to uniquely identify this message
  action: [string],   // Identifies the action performed on the message. Valid values (from Message.action): 'log', 'send'
  source: [string],  // Identifies if this is a message that had been issued by this Catenis node (value = 'local') or by another Catenis node (value = 'remote')
  originDeviceId: [string],  // External ID of the device that logged/sent the message
  targetDeviceId: [string],  // External ID of the device to which message had been sent. This field should only be present for sent messages (action = 'send')
  readConfirmationEnabled: [boolean],  // Indicates whether message was sent with read confirmation enabled. This field should only be present for sent messages (action = 'send')
  isEncrypted: [boolean],   // Indicates whether stored message is encrypted
  offChain: {  // This field should only exist for off-chain messages
    msgEnvCid: [string]  // IPFS CID of the Catenis off-chain message envelope used to record the message
  },
  blockchain: {  // In case of off-chain messages, this field is only written at a later time when the Settle Off-Chain Messages tx is sent
    txid: [string],  // Blockchain attributed ID (hash) of transaction created to record the message or, in case of off-chain messages, to settle the off-chain messages onto the blockchain
    confirmed: [boolean]  // Indicates whether transaction created to record the message has already been confirmed
  },
  externalStorage: {
    provider: [string],  // Name of external storage provider that was used to store message
    reference: [string]  // Reference to message in the external storage
  },
  createdDate: [date/time],  // Date and time when doc/rec has been created
  sentDate: [date/time],  // Date and time when message has been sent. This field is only available for 'local' messages
  receivedDate: [date/time],  // Date and time when message has been received. This field only exists for 'send' messages after they had actually been received.
  blocked: [boolean],  // Identifies a 'send' message that should have been received but instead had been blocked (due to the intended receiving device not being active or its permission setting). Note that this field should never exist along with the receivedDate field; only one of these fields should exist for a given Message doc (for 'send' message after it had been received/blocked). Also, if present, this field should always have the value true
  firstReadDate: [date/time],  // Date and time when message has first been read (by the device that logged it, or by its intended receiver in case of a 'send' message)
                               //  NOTE: this field is available for both 'local' and 'remote' messages, and only once the message has been read at least once.
                               //   However, for 'local' messages sent to a remote Catenis node, it shall only be available if the message had read confirmation enabled and the target device allows for message read notification.
  lastReadDate: [date/time],  // Date and time when message has last been read (by the device that logged it, or by its intended receiver in case of a 'send' message)
                              //  NOTE: this field is available for both 'local' and 'remote' messages, and only once the message has been read at least once.
                              //    However, it is not available for 'local' messages sent to a remote Catenis node
  readConfirmed: [boolean]  // Indicates that a read confirmation had already been received for this message. This field should only exist (with the value true) for messages that had read confirmation enabled and after a read confirmation had been received
}

// Used to record (log/send) messages in chunks
ProvisionalMessage {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  provisionalMessageId: [string],  // External ID used to uniquely identify this provisional message
  deviceId: [string],  // External ID of device to which this message belongs
  action: [string],   // Identifies the action to be performed on the message. Valid values (from Message.action): 'log', 'send'
  progress: {   // Note: this field should not exist until the message's final message chunk is recorded (received by Catenis but not yet stored to external storage/added to the blockchain)
    bytesProcessed: [number],  // Total number of bytes of message that had already been processed (stored to external storage)
    done: [boolean],           // Indicates whether processing had been finalized (message added to blockchain), either successfully or with error
    success: [boolean],        // Indicates whether message had been successfully processed
    error: {
      code: [number],    // Code number of error that took place while processing the message
      message: [string]  // Text describing the error that took place while processing the message
    },
    finishDate: [date/time]    // Date and time when processing was finalized
  },
  messageId: [string],   // External ID of recorded Catenis message.
                         //  Note: this field should only exist after the message has been successfully processed
  createdDate: [date/time]  // Date and time when doc/rec has been created
}

// Used to read messages in chunks
CachedMessage {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  cachedMessageId: [string],  // External ID used to uniquely identify this cached message
  deviceId: [string],  // External ID of device to which this message belongs
  action: [string],   // Identifies the action to be performed on the message. Valid values (from Message.action): 'read'
  messageId: [string],  // External ID of message being read
  dataChunkSize: [number],  // Maximum size, in bytes, of the data chunks of this message
  progress: {
    bytesProcessed: [number],  // Total number of bytes of message that had already been processed (retrieved from external storage)
    done: [boolean],           // Indicates whether processing had been finalized (message completely retrieved), either successfully or with error
    success: [boolean],        // Indicates whether message had been successfully processed
    error: {
      code: [number],    // Code number of error that took place while processing the message
      message: [string]  // Text describing the error that took place while processing the message
    },
    finishDate: [date/time]    // Date and time when processing was finalized
  },
  msgInfo: [Object],  // Object containing information about the retrieved message. Note: this field should only exist after the message has been successfully processed
  chunksRead: [number],  // Number of message chunks associated with this message that have already been read.
                         //  Note: this field should only exist after the message has been successfully processed
  readFinalized: [boolean],  // Indicates whether all message chunks have already been read.
                             //  Note: this field should only exist after the message has been successfully processed
  lastReadDate: [date/time],  // Date and time when the last message chunk reading took place
                              //  Note: this field should only exist after at least one of the message chunks has been read
  createdDate: [date/time]  // Date and time when doc/rec has been created
}

MessageChunk {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  messageChunkId: [string],  // External ID used to uniquely identify this message chunk. Note: this should be used as a continuation token
                             //  for recording/reading the next message chunk of the associated message
  type: [string],  // Identifies to type of ephemeral message to which this message chunk belongs. Valid values (from Catenis.MessageChunk.type): 'provisional', 'cached'
  ephemeralMessage_id: [string],  // MongoDB internal ID of the ephemeral message doc/rec (either ProvisionalMessage or CachedMessage, depending on type) to which this message chunk belongs
  order: [number],  // The order (starting from 1) that this message chunk occupies in the whole message contents
  isFinal: [boolean],  // Indicates whether this is the last message chunk of the message
  data: [binary],  // The data that comprises this message chunk
  createdDate: [date/time]  // Date and time when doc/rec has been created
}

SentTransaction {
  _id: [string], // MongoDB internal document ID provided by Meteor
  type: [string], // Identifies the type of transaction that was sent. Valid values (from Catenis.Transaction.type): 'funding', 'credit_service_account', 'store_bcot', 'redeem_bcot', 'spend_service_credit', 'send_message', 'log_message', 'read_confirmation', 'issue_asset', 'transfer_asset', 'settle_off_chain_messages'
  txid: [string], // Blockchain attributed ID (hash) of the sent transaction
  sentDate: [date/time], // Date and time when transaction was sent to the blockchain network
  confirmation: {
    confirmed: [boolean], // Indicates whether this transaction has already been confirmed within the blockchain
    blockHash: [string], // Hash (ID) of blockchain block that contains this transaction
    confirmationDate: [date/time], // Date and time when transaction has been confirmed. This is derived from the block time
  },
  replacedByTxid: [string], // Blockchain attributed ID (hash) of the transaction that replaces (by means of the RBF - Replace By Fee feature) this transaction (which in turn shall never make to the blockchain and thus shall never be confirmed).
                            //  This is primarily intended for transactions of the 'read_confirmation' and 'spend_service_credit' types. This field should only exist if the transaction has been replaced, and it will be set to null to indicate that the transaction that it replaced (directly or indirectly via its ancestors) had actually been confirmed later
  info: {  // Specific information about the transaction according to its type
    funding: {  // Information for funding transactions
      event: {
        name: [string], // Identifies the event that triggered the funding action. Valid values (from Catenis.FundTransaction.fundingEvent): 'provision_system_device', 'provision_service_credit_issuance', 'provision_bcot_sale_stock', 'provision_client_device', 'add_extra_service_payment_tx_pay_funds', 'add_extra_tx_pay_funds', 'add_extra_read_confirm_tx_pay_funds', 'add_extra_settle_oc_msgs_tx_pay_funds'
        entityId: [string] // Id of the entity associated with the event. Should only exist for 'provision_client_device' events, and it refers to the deviceId
      },
      payees: [Array(string)] // Identifies the type of blockchain addresses that receive the funds. Valid values (from Catenis.KeyStore.extKeyType): 'sys_dev_main_addr', 'sys_pay_tx_exp_addr', 'sys_read_conf_pay_tx_exp_addr', 'sys_serv_cred_issu_addr', 'sys_serv_pymt_pay_tx_exp_addr', 'sys_oc_msgs_setlmt_pay_tx_exp_addr', 'cln_msg_crd_addr', 'cln_asst_crd_addr', 'dev_main_addr', 'dev_asst_issu_addr'
    },
    creditServiceAccount: { // Information for credit service account transaction
      clientId: [string], // External ID of client whose service account is being credited
      creditedAmount: [number]  // Amount, in Catenis service credit "satoshis", to be credited to client's service account
    },
    storeBcot: { // Information for store BCOT transaction
      storedAmount: [number],  // Amount, in BCOT token "satoshis", stored
      omniTxValidity: {	  // Note: this field only exists after the transaction is confirmed (and the method used to handle the confirmation of such tx has properly checked its validity)
      	isValid: [boolean],  // Indicates whether this is a valid Omni transaction
      	invalidReason: [string]  // Reason for this Omni transaction not being valid. Note: this field only exists if Omni transaction is not valid (omniTx.isValid = false)
      }
    },
    redeemBcot: { // Information for redeem BCOT transaction
      clientId: [string],  // External ID of client for which purchased BCOT tokens have been redeemed for Catenis service credits
      redeemedAmount: [number],  // Amount, in BCOT token "satoshis", redeemed
      omniTxValidity: {	  // Note: this field only exists after the transaction is confirmed (and the method used to handle the confirmation of such tx has properly checked its validity)
      	isValid: [boolean],  // Indicates whether this is a valid Omni transaction
      	invalidReason: [string]  // Reason for this Omni transaction not being valid. Note: this field only exists if Omni transaction is not valid (omniTx.isValid = false)
      }
    },
    spendServiceCredit: { // Information for spend service credit transaction
      clientIds: [Array(string)],  // External ID of clients that are the owners of the service account from where Catenis service credits are spent
      serviceTxids: [Array(string)],  // Blockchain assigned ID of transactions used to convey service that are paid by this tx
      ocMsgServiceCids: [Array(string)]  // IPFS CID of Catenis off-chain message envelopes used to convey off-chain message related services (log/send off-chain messages)
    },
    sendMessage: { // Information for send message transactions
      originDeviceId: [string], // External ID of the device that sent the message
      targetDeviceId: [string], // External ID of the device that receives the message
      readConfirmation: {  // This field should only exist for messages sent with read confirmation enabled
        vout: [integer] // The index of the output within this transaction that is used for read confirmation
      }
    },
    logMessage: { // Information for log message transactions
      deviceId: [string] // External ID of the device that logged the message
    },
    readConfirmation: {
      serializedTx: {   // Object from serialized tx minus useOptInRBF and txid properties
        inputs: [{
          txid: [string],    // Blockchain assigned ID of transaction containing output that is spent by this input
          vout: [number],    // Index which identifies the output that is spent by this input
          amount: [number],  // Amount, in satoshis, associated with the output that is spent by this input
          addrPath: [string] // HD node path of the blockchain address associated with the output that is spent by this input
        }],
        outputs: [{
          type: [string],           // Identifies the type of the output. Either: 'P2PKH', 'P2SH'
          addrPath: [string],       // HD node path of the blockchain address to where payment should be sent
          amount: [number],         // Amount, in satoshis, to send
        }]
      },
      spentReadConfirmTxOutCount: [number]  // Number of send message tx read confirmation address outputs that had been spent by this tx
    },
    issueAsset: {
      assetId: [string], // ID that uniquely identifies the Catenis asset that is issued
      issuingDeviceId: [string], // External ID of the device that issued the asset
      holdingDeviceId: [string], // External ID of the device for which the asset is issued and that shall hold it
      amount: [number]           // Amount of asset issued
    },
    transferAsset: {
      assetId: [string], // ID that uniquely identifies the Catenis asset that is transferred
      sendingDeviceId: [string],   // External ID of the device that sent the assets
      receivingDeviceId: [string], // External ID of the device that receives the assets
      amount: [number],            // Amount of asset transferred
      changeAmount: [number]       // Amount of asset sent back to sending device as change
    },
    settleOffChainMessages: {
      offChainMsgDataCids: [Array(string)]  // List of IPFS CIDs of Catenis off-chain message data (either envelope or receipt) that have been settled to the blockchain
    }
  },
  originalTxid: [string]  // Blockchain attributed ID (hash) that had been originally assigned to the transaction. If this field exists, it means that this transaction's ID had been modified due to malleability, and the txid field has the modified tx id.
}

ReceivedTransaction {
  _id: [string], // MongoDB internal document ID provided by Meteor
  type: [string], // Identifies the type of transaction that was received. Valid values (from Catenis.Transaction.type): 'sys_funding', 'bcot_payment', 'bcot_replenishment', 'credit_service_account', 'send_message', 'read_confirmation', 'issue_asset', 'transfer_asset', 'settle_off_chain_messages'
                  //  Note: only settle off-chain messages tx containing off-chain message envelopes saved by this Catenis node or off-chain message receipts for off-chain message envelopes sent by this Catenis node are added to this DB collection
  txid: [string], // Blockchain attributed ID (hash) of the received transaction
  receivedDate: [date/time], // Date and time when transaction was received. This is derived from timereceived property returned by gettransaction RPC method
  sentTransaction_id: [string], // MongoDB internal ID of SentTransaction doc/rec which corresponds to this transaction. This field should be filled (exist) for all received transactions that have been sent by this Catenis node. Note that for transactions of the 'sys_funding' type this field must never be filled (exist) since those types of transactions are not sent by the system
  confirmation: {   // This field should only exist for received transaction that are not associated with a sent transaction (field sentTransaction_id non-existent)
    confirmed: [boolean], // Indicates whether this transaction has already been confirmed within the blockchain
    blockHash: [string], // Hash (ID) of blockchain block that contains this transaction
    confirmationDate: [date/time] // Date and time when transaction has been confirmed. This is derived from the block time
  },
  info: {  // Specific information about the transaction according to its type.
    sysFunding: {
      fundAddresses: [{ // List identifying the Catenis system funding addresses through which funds have been received
        path: [string],     // HD node path of the address
        amount: [number]    // Amount, in satoshis, of funds paid to the specified address
    }],
    bcotPayment: { // Information for BCOT payment transaction
      clientId: [string],  // External ID of client for which payment is made
      encSentFromAddress: [string],  // Base-64 formatted encrypted blockchain address from where the BCOT tokens used for the payment were sent.
                                     //  Note: this address is encrypted using the bcotPayAddress's crypto keys
      bcotPayAddressPath: [string],  // HD node path of the address used to receive the BCOT payment
      paidAmount: [number],  // Amount, in BCOT token "satoshis", paid
      omniTxValidity: {	  // Note: this field only exists after the transaction is confirmed (and the method used to handle the confirmation of such tx has properly checked its validity)
      	isValid: [boolean],  // Indicates whether this is a valid Omni transaction
      	invalidReason: [string]  // Reason for this Omni transaction not being valid. Note: this field only exists if Omni transaction is not valid (omniTx.isValid = false)
      }
    },
    bcotReplenishment: { // Information for BCOT replenishment transaction
      encSentFromAddress: [string],  // Base-64 formatted encrypted blockchain address from where the BCOT tokens were sent.
                                     //  Note: this address is encrypted using the BCOT token sale stock address's crypto keys
      replenishedAmount: [number],  // Amount, in BCOT token "satoshis", sent for the replenishment of the BCOT token sale stock
      omniTxValidity: {	  // Note: this field only exists after the transaction is confirmed (and the method used to handle the confirmation of such tx has properly checked its validity)
      	isValid: [boolean],  // Indicates whether this is a valid Omni transaction
      	invalidReason: [string]  // Reason for this Omni transaction not being valid. Note: this field only exists if Omni transaction is not valid (omniTx.isValid = false)
      }
    },
    creditServiceAccount: { // Information for credit service account transaction
      clientId: [string], // External ID of client whose service account is being credited
      creditedAmount: [number]  // Amount, in Catenis service credit "satoshis", to be credited to client's service account
    },
    sendMessage: { // Information for send message transactions
      originDeviceId: [string], // External ID of the device that sent the message
      targetDeviceId: [string], // External ID of the device that receives the message
      readConfirmation: {   // This field should only exist for messages that had been sent with read confirmation enabled
        vout: [integer], // The index of the output within this transaction that is used for read confirmation
        spent: [boolean] // Indicates whether the read confirmation output has already been spent by a transaction (of the 'read_confirmation' type)
      }
    },
    readConfirmation: {
      spentReadConfirmTxOuts: [{ // Identifies the read confirmation tx outputs that are spent by this transaction
        txid: [string], // Blockchain attributed ID of the transaction containing the read confirmation output that is spent
        vout: [integer] // The index of the output within the transaction that is spent
      }]
    },
    issueAsset: {
      assetId: [string], // ID that uniquely identifies the Catenis asset that is issued
      issuingDeviceId: [string], // External ID of the device that issued the asset
      holdingDeviceId: [string], // External ID of the device for which the asset is issued and that shall hold it
      amount: [number]           // Amount of asset issued
    },
    transferAsset: {
      assetId: [string], // ID that uniquely identifies the Catenis asset that is transferred
      sendingDeviceId: [string],   // External ID of the device that sent the assets
      receivingDeviceId: [string], // External ID of the device that receives the assets
      amount: [number],            // Amount of asset transferred
      changeAmount: [number]       // Amount of asset sent back to sending device as change
    },
    settleOffChainMessages: {
      offChainMsgDataCids: [Array(string)]  // List of IPFS CIDs of Catenis off-chain message data (either envelope or receipt) that have been settled to the blockchain
    }
  },
  originalTxid: [string]  // Blockchain attributed ID (hash) that had been originally assigned to the transaction. If this field exists, it means that this transaction's ID had been modified due to malleability, and the txid field has the modified tx id.
}

SavedOffChainMsgData {
  _id: [string], // MongoDB internal document ID provided by Meteor
  dataType: [string],  // Identifies the type of Catenis off-chain message data that was saved. Valid values (from ctnOffChainLib.OffChainData.msgDataType): 'msg-envelope', 'msg-receipt'
  msgType: [string],  // Identifies the type of message referred by the Catenis off-chain message envelope. Valid values (from ctnOffChainLib.MessagEnvelope.msgType): 'log-message', 'send-message'.
                      //  Note: this field should only exist when dataType field equals 'msg-envelope'
  cid: [string],  // IPFS CID of Catenis off-chain message data
  savedDate: [date/time],  // Date and time when Catenis off-chain message data has been saved to Catenis node's IPFS repository
  settlement: {
    settled: [boolean],  // Indicates whether this Catenis off-chain message has already been settled to the blockchain
    settleOffChainMsgsTxid: [string]  // Blockchain attributed ID (hash) of the transaction used to settle this Catenis off-chain message to the blockchain (Settle Off-Chain Messages tx)
  },
  info: {  // Specific information about the Catenis off-chain message data according to its type
    msgEnvelope: {
      logMessage: {
        deviceId: [string] // External ID of the device that logged the message
      },
      sendMessage: {
        originDeviceId: [string], // External ID of the device that sent the message
        targetDeviceId: [string] // External ID of the device that receives the message
      }
    }
    msgReceipt: {
      sendMsgEnvelopeCid: [string]  // IPFS CID of Catenis off-chain message envelope that refers to the sent message for which this receipt is issued
    }
  }
}

RetrievedOffChainMsgData {
  _id: [string], // MongoDB internal document ID provided by Meteor
  dataType: [string],  // Identifies the type of Catenis off-chain message data that was retrieved. Valid values (from ctnOffChainLib.OffChainData.msgDataType): 'msg-envelope', 'msg-receipt'
  msgType: [string],  // Identifies the type of message referred by the Catenis off-chain message envelope. Valid values (from ctnOffChainLib.MessagEnvelope.msgType): 'send-message'.
                      //  Note: this field should only exist when dataType field equals 'msg-envelope'
  cid: [string],  // IPFS CID of Catenis off-chain message data
  savedDate: [date/time],  // Date and time when Catenis off-chain message data has been saved to Catenis node's IPFS repository
  retrievedDate: [date/time],  // Date and time when Catenis off-chain message data has been retrieved from Catenis node's IPFS repository
  savedOffChainMsgData_id: [string], // MongoDB internal ID of SavedOffChainMsgData doc/rec which corresponds to this Catenis off-chain message data.
                                     //  Note: this field should be filled (exist) for all saved Catenis off-chain message data that have been saved by this Catenis node.
  info: {  // Specific information about the Catenis off-chain message data according to its type
    msgEnvelope: {
      sendMessage: {
        originDeviceId: [string], // External ID of the device that sent the message
        targetDeviceId: [string] // External ID of the device that receives the message
      }
    }
    msgReceipt: {
      sendMsgEnvelopeCid: [string]  // IPFS CID of Catenis off-chain message envelope that refers to the sent message for which this receipt is issued
    }
  }
}

Malleability {
  _id: [string], // MongoDB internal document ID provided by Meteor
  source: [string],  // Source (from Catenis node's point of view) of transaction the txid of which got changed due to malleability. Valid values: 'sent_tx', 'received_tx'
  originalTxid: [string],  // Original blockchain attributed ID (hash) of the transaction
  modifiedTxid: [string],  // New blockchain attributed ID (hash) of transaction due to malleability
  createdDate: [date/time]  // Date and time when record has been created
}

Permission {
  _id: [string], // MongoDB internal document ID provided by Meteor
  event: [string], // Name of event for which permission is being defined. Valid values (from Permission.event): 'receive-notify-new-msg', 'receive-notify-msg-read', 'receive-notify-asset-of', 'receive-notify-asset-from', 'receive-notify-confirm-asset-of', 'receive-notify-confirm-asset-from', 'send-read-msg-confirm', 'receive-msg', 'disclose-main-props', 'disclose-identity-info', 'receive-asset-of', 'receive-asset-from'
  subjectEntityType: [string],  // The type of the subject entity: either 'client' or 'device'
  subjectEntityId: [string], // ID of device that functions as the subject of the action associated with the event for which permission is being defined (subjectEntityType = 'device'),
                             //  or ID of client for which default permission for all its devices is being set (subjectEntityType = 'client')
  level: [string], // Designates upon which devices the permission right should be applied. Valid values (from Permission.level): '1.device', '2.client', '3.catenis_node', '4.system'
  objectEntityId: [string], // Identifies the device that functions as the object of the action associated with the event and upon which the permission right should be applied
                            //  If level = 'device', it should contain a device ID, and the permission right applies to a given device.
                            //  If level = 'client', it should contain a client ID, and the permission right applies to any devices that belongs to that client.
                            //  If level = 'catenisNode', it should contain a Catenis Node index, and the permission right applies to any devices that belong to any clients that pertain to that Catenis node.
                            //  If level = 'system', this field should not exist, and the permission right applies to any devices
  right: [string]  // The permission right that should be applied: allow, deny
}

Asset {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  assetId: [string],  // (Catenis attributed) External ID used to uniquely identify this asset
  ccAssetId: [string],  // Colored Coins attributed ID of the asset
  type: [string],  // The type of Catenis asset. Valid values (from Asset.type): 'system' or 'device'
  name: [string],  // The asset name
  description: [string],  // A short description about the asset
  issuingType: [string],  // Type of Colored Coins asset in regards to issuing; either 'locked' or 'unlocked' (more of the same asset can be reissued)
  issuance: {
    entityId: [string],  // ID of the device that first issued this asset (for type = 'device').
                         //  If type = 'system', it is actually a Catenis Node index
    addrPath: [string]  // The HD node path which identifies the blockchain address used for issuing 'unlocked' asset. It should only exist for issuingType = 'unlocked'
  },
  divisibility: [number],  // Number of decimal places allowed for representing quantities of this asset
  isAggregatable: [boolean],  // Indicates whether quantities of the asset from different UTXOs can be combined
  createdDate: [date/time],  // Date and time when doc/rec has been created
}

BcotExchangeRate {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  exchangeRate: [number],  // Bitcoin to BCOT token exchange rate
  date: [date/time],  // Date and time when exchange rate has been recorded
  createdDate: [date/time]  // Date and time when doc/rec has been created
}

Billing {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  type: [string],  // The type of billing doc/rec. Available values (from Billing.docType): 'original', 'complementary'
  clientId: [string],  // ID of client to which service is charged
  deviceId: [string],  // ID of device that actually consumed the service
  billingMode: [string],  // Billing mode used for charging the service. Available values (from Client.billingMode): 'pre-paid', 'post-paid'
  service: [string],  // Name of the consumed service. Available values (from Service.clientPaidService): 'log_message', 'send_message', 'send_msg_read_confirm', 'issue_asset', 'transfer_asset'
  serviceDate: [date/time],  // Date and time when service has been consumed
  serviceTx: {  // Catenis transaction used to convey the consumed service
    txid: [string],  // Blockchain attributed ID (hash) of service transaction
    fee: [number],   // Amount, in satoshis, paid as fee for the service transaction
    complementaryTx: {  // Catenis transaction that complements the service transaction. This field should only exist if the service transaction requires a complementary transaction, which is currently only true for 'send_msg_read_confirm' service.
                        //  It is mainly used to record the read confirmation transaction for 'send_msg_read_confirm' service, and will only be added after the read confirmation tx is confirmed.
                        //  Note: it will only be included in the "original" billing doc/rec if read confirmation tx is issued from the same Catenis node that sent the message or if a read notification is actually sent.
                        //         Otherwise, a "complementary" billing doc/rec shall be created at the Catenis node that issued the read confirmation tx to register the cost of the complementary (read confirmation) tx.
                        //         This "complementary" doc/rec shall only include the following fields: type, clientId, deviceId, service, serviceTx.txid, serviceTx.complementaryTx.txid, serviceTx.complementaryTx.fee, createdDate
      txid: [string],  // Blockchain attributed ID (hash) of the complementary (read confirmation) transaction
      fee: [number],  // Amount, in satoshis, paid as fee for the complementary (read confirmation) transaction
      feeShare: [number]  // Amount, in satoshis, that represents the portion of the fee paid for the complementary (read confirmation) transaction that applies to this specific service (sent message)
    }
  },
  offChainMsgServiceData: {  // Catenis off-chain message data structures used to convey off-chain message related services (log_off_chain_message, send_off_chain_message and send_off_chain_msg_read_confirm)
    msgEnvelope: {
      cid: [string],  // IPFS CID of Catenis off-chain message envelope
      settlementTx: {
        txid: [string],  // Blockchain attributed ID (hash) of settle off-chain messages transaction containing this Catenis off-chain message envelope
        fee: [number],   // Amount, in satoshis, paid as fee for the settle off-chain messages transaction
        feeShare: [number]  // Amount, in satoshis, that represents the portion of the fee paid for the settle off-chain messages transaction that applies to this specific (off-chain message related) service
      }
    },
    msgReceipt: {  // This field should only exist for 'send_off_chain_msg_read_confirm' service, after a Catenis off-chain message receipt data structure is retrieved (and this will only happen if the target device accepts the message and allows read message confirmation to be sent back to the origin device)
      cid: [string],  // IPFS CID of Catenis off-chain message receipt
      settlementTx: {
        txid: [string],  // Blockchain attributed ID (hash) of settle off-chain messages transaction containing this Catenis off-chain message receipt
        fee: [number],   // Amount, in satoshis, paid as fee for the settle off-chain messages transaction
        feeShare: [number]  // Amount, in satoshis, that represents the portion of the fee paid for the settle off-chain messages transaction that applies to this specific (off-chain message related) service
      }
    }
  },
  estimatedServiceCost: [number], - Estimated cost, in satoshis, of the service
  priceMarkup: [number], - Markup used to calculate the price of the service
  btcServicePrice: [number], - Price of the service expressed in (bitcoin) satoshis
  bitcoinPrice: [number], - Bitcoin price, in USD, used to calculate the exchange rate
  bcotPrice: [number], - BCOT Token price, in USD, used to calculate to exchange rate
  exchangeRate: [number], - Bitcoin to BCOT token (1 BTC = x BCOT) exchange rate used to calculate final price
  finalServicePrice: [number] - Price charged for the service expressed in Catenis service credit's lowest units
  servicePaymentTx: {  // Catenis transaction used to pay for service
    txid: [string],  // Blockchain attributed ID (hash) of transaction used to pay for service expense.
                     //  Can be either a Spend Service Credit tx or a Debit Service Account tx, depending if the billing mode is 'pre-paid' or 'post-paid' respectively
    confirmed: [boolean],  // Indicates whether service payment transaction has already been confirmed
    fee: [number],  // Amount, in satoshis, paid as fee for the service payment transaction.
                    //  Note: since service payment transactions make use RBF (replace by fee), the actual fee spent is only obtained after the transaction is confirmed
    feeShare: [number]  // Amount, in satoshis, that represents the portion of the fee paid for the service payment transaction that applies this specific service
  },
  createdDate: [date/time]  // Date and time when doc/rec has been created
}

CCMetadataConversion {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  torrentHash: [string],  // Torrent hash of Colored Coins metadata
  cid: [string],  // Hex encoded CID on IPFS of converted Colored Coins metadata
  createdDate: [date/time]  // Date and time when doc/rec has been created
}

BcotProduct {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  sku: [string],  // Stock keeping unit, for this product (e.g. CTN-0010BCOT)
  amount: [number]  // Predefined amount, in BCOT token "satoshis", being sold
  active: [boolean],  // Indicates whether this BCOT product is active and still in use
  createdDate: [date/time],  // Date and time when doc/rec has been created
  deactivatedDate: [date/time]  // Date and time when BCOT token product has been deactivated
}

BcotSaleAllocation {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  summary: [{  // Total quantities per SKU allocated
      sku: [string],  // SKU identifying the allocated BCOT product
      quantity: [number]  // Quantity of the BCOT product that had been allocated
  }],
  status: [string],  // The current status of this BCOT token sale allocation. Valid values (from BcotSaleAllocation.status): 'new', 'in_use'
  allocationDate: [date/time],  // Date and time when allocation was done
  lastStatusChangedDate: [date/time]  // Date and time when status has been last modified
}

BcotSaleAllocationItem {
  _id: [string],  // MongoDB internal document ID provided by Meteor
  bcotSaleAllocation_id: [string],  // MongoDB internal ID of BcotSaleAllocation doc/rec to which this allocation item belongs
  sku: [string],  // SKU identifying the BCOT product that had been allocated for sale
  purchaseCode: [string],  // Code to be used to redeem the (purchased) BCOT tokens for Catenis service credits (referred in the UI as `voucher ID`)
  redemption: {
    redeemed: [boolean],  // Indicates whether the purchased BCOT tokens have already been redeemed
    client_id: [string],  // MongoDB internal ID of Client doc/rec that redeemed the purchased BCOT tokens
    redeemedDate: [date/time],  // Date and time when purchased BCOT tokens have been redeemed
    redeemBcotTxid: [string]  // Blockchain attributed ID (hash) of transaction used to redeem purchased BCOT tokens for Catenis service credits
  }
}