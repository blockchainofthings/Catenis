// Default configuration file
{
  // Parameters pertaining to the Catenis application
  "application": {
    "appName": "Catenis",
    ctnNode: {  // Catenis node to which this instance of the application corresponds
      index: 0,
      privKey: "????",  // Base64 encoded, ciphered key
      pubKey: ""
    },
    "environment": "production",
    enableSelfRegistration: false,  // Indicates whether the UI should include a link from where the end user can register for a new Catenis account.
    twoFAForEndUsers: true,  // Indicates whether two-factor authentication should be made available for end users. Note that it is always available for admin users.
    testPrefix: null,  // (optional) A prefix used to differentiate non-production environments
    masterSeed: "????",  // Base64 encoded, ciphered Catenis master seed
    commonSeed: "????",  // Base64 encoded, ciphered Catenis common seed
    "cryptoNetwork": "testnet",  // Available values: 'bitcoin' (for Bitcoin's production blockchain), 'testnet' (for Bitcoin's test blockchain)
    "shutdownTimeout": 30000,   // (30 sec.) Time, in milliseconds, that the application should wait after it receives a terminate request before it actually terminates
    "adminRole": "sys-admin",  // User role for application administration
    defaultAdminUser: {
      username: null,  // (optional) Username of application default admin user
      psw: null,  // (optional) Base64 encoded, ciphered password for application default admin user
      email: null  // (optional) Email address of application default admin user
    }
  },
  // Parameters pertaining to the SetUpCipherFunctions module
  setUpCipherFunctions: {
    cipherProbe: {
      data: "????",  // Base64 encoded, ciphered text used to validate cipher/decipher functions
      hash: "????"  // Base64 encoded, SHA256 hash of deciphered text
    }
  },
  // Parameters pertaining to the Startup module
  "startup": {
    "fixMissingAddresses": false,  // Indicate if issued blockchain addresses are missing from BitcoinCore wallet they should be automatically included
    legacyDustFunding: false,  // Indicates whether the system should use the legacy behavior when funding addresses that are funded with dust amount (service credit issuance, BCOT sale stock, system device main, device main, device asset issuance)
                               //  NOTE: this option is intended to simulate an old scenario while working on the implementation of segregated witness support
    fixDustFunding: false,  // Indicates whether addresses that are funded with dust amount (service credit issuance, BCOT sale stock, system device main, device main, device asset issuance) should be refunded to use the new, lower dust amount for segregated witness output
    "bypassProcessing": false,  // NOTE: this option is for DEBUG ONLY. Bypass all processing, so the app starts but does not do anything. This allows
                                //  for debugging via 'meteor shell' or 'meteor mongo'
    "dataToCipher": null,  // A text that should be ciphered by the application. If set, the Catenis application is started in "bypass processing" mode and will output the ciphered data
    dataToDecipher: null,  // A base64 encoded, ciphered text that should be deciphered by the application. If set, the Catenis application is started in "bypass processing" mode and will output the deciphered data
    "pidFilename": "catenis-pid"  // Name of the file containing the ID of the current process that is created/updated whenever that app starts
  },
  // Parameters pertaining to e-mail server configuration
  "email": {
    "smtpHost": "localhost",
    "secureProto": null,  // (optional, can be set to null) Secure protocol that should be used with SMTP server. Valid options: 'ssl' or 'tls'
    "smtpPort": null,  // (optional, can be set to null) To be set only if different than default (depending on secureProto): none/null (25), ssl (465), tls (587)
    "username": null,  // (optional, can be set to null) To be set only if required by SMTP host
    "password": null  // (optional, can be set to null) Base64 encoded, ciphered password to access the SMTP host (if required)
  },
  // Parameters pertaining to logging mechanism
  "logging": {
    "exitOnError": true,
    "objInspectionDepth": 4,
    "console": {
      "active": true,
      "logLevel": "INFO" // Valid options: ALL, TRACE, DEBUG, INFO, WARN, ACTION, ERROR, FATAL
    },
    "file": {
      "active": true,
      "logLevel": "DEBUG", // Valid options: ALL, TRACE, DEBUG, INFO, WARN, ACTION, ERROR, FATAL
      "logDir": "log",
      "logFilename": "catenis-%DATE%.log",
      "maxDays": 90
    },
    "email": {
      "active": true,
      "logLevel": "WARN", // Valid options: ALL, TRACE, DEBUG, INFO, WARN, ACTION, ERROR, FATAL
      "toAddresses": "andre@blockchainofthings.com", // Can be set to a comma separated list of e-mail addresses
      "fromAddress": "Catenis <noreply@blockchainofthings.com>",
      "subject": "{{level}} - {{msg}}"
    }
  },
  // Parameters pertaining to Database module
  "database": {
    "defaultBcotPrice": 0.75,  // Default BCOT token price (to be used if no price set yet)
    "defaultLicenses": [{
      "level": "Enterprise",  // Name used to identify the license level
      "order": 10,  // The order associated with the license level. The lower the order, the less restrictive (e.g. maximum number of devices) the license is
      "type": "annual",  // Used to identify any characteristics that differentiate this specific license
      "revision": 0,  // The revision number of the license. Revisions are used to change some characteristics of a license (level & type) (e.g. maximum number of devices)
      // Unlimited number of devices
      "validityMonths": 12, // Period of time, in months, through which this license is valid
      "provisionalRenewalDays": 7 // The duration, in days, for the provisional renewal of this license
    }, {
      "level": "Professional",  // Name used to identify the license level
      "order": 20,  // The order associated with the license level. The lower the order, the less restrictive (e.g. maximum number of devices) the license is
      "type": "annual",  // Used to identify any characteristics that differentiate this specific license
      "revision": 0,  // The revision number of the license. Revisions are used to change some characteristics of a license (level & type) (e.g. maximum number of devices)
      "maximumDevices": 200,  //Maximum number of client devices that can be active at any time
      "validityMonths": 12, // Period of time, in months, through which this license is valid
      "provisionalRenewalDays": 7 // The duration, in days, for the provisional renewal of this license
    }, {
      "level": "Basic",  // Name used to identify the license level
      "order": 30,  // The order associated with the license level. The lower the order, the less restrictive (e.g. maximum number of devices) the license is
      "type": "annual",  // Used to identify any characteristics that differentiate this specific license
      "revision": 0,  // The revision number of the license. Revisions are used to change some characteristics of a license (level & type) (e.g. maximum number of devices)
      "maximumDevices": 20,  // Maximum number of client devices that can be active at any time
      "validityMonths": 12, // Period of time, in months, through which this license is valid
      "provisionalRenewalDays": 7 // The duration, in days, for the provisional renewal of this license
    }, {
      "level": "Starter",  // Name used to identify the license level
      "order": 40,  // The order associated with the license level. The lower the order, the less restrictive (e.g. maximum number of devices) the license is
      // No specific type
      "revision": 0,  // The revision number of the license. Revisions are used to change some characteristics of a license (level & type) (e.g. maximum number of devices)
      "maximumDevices": 2  // Maximum number of client devices that can be active at any time
      // Never expires
      // No provisional renewal
    }],
    "defaultBcotProducts": [] // Should be defined on each environment's config file
  },
  // Parameters pertaining to ParseRequestBody module
  "parseRequestBody": {
    "reqBodySizeLimit": 15  // Maximum size, in MB, of data that can be received as the body of requests to the Catenis API methods
  },
  // Parameters pertaining to CompressResponseBody module
  "compressResponseBody": {
    "useCompression": true,   // Indicate whether response body should be compressed
    "compressThreshold": 1024   // Minimum size, in bytes, of response body for it to be compressed
  },
  // Parameters pertaining do BitcoinFees module
  bitcoinFees: {
    implementationInUse: 'earnBitcoinFees'  // Name of bitcoin fees implementation that should be used. Available values: 'earnBitcoinFees', 'bitcoinCoreFees'
  },
  // Parameters pertaining to EarnBitcoinFees module
  "earnBitcoinFees": {
    "apiVer1Url": "https://bitcoinfees.earn.com/api/v1/fees/",  // URL of version 1 of BitcoinFees API provided by Earn.com (former 21.co)
    "recommendedFeesEndPoint": "recommended",  // Endpoint of BitcoinFees API method for retrieving recommended fees
    "listFeesEndPoint": "list",  // Endpoint of BitcoinFees API method for retrieving complete list of fees
    "retrieveFeesInterval": 21600000,  // (6 hours) Time interval, in milliseconds, for executing method to retrieve latest bitcoin fees
    "numDbRecsToMaintain": 2000,  // Number of database docs/recs used to store latest fees that should be maintained when purging the database
    "dbPurgeHours": 2,  // Hours component of time when database purge should take place
    "dbPurgeMinutes": 0,  // Minutes component of time when database purge should take place
    "dbPurgeSeconds": 0,  // Seconds component of time when database purge should take place
    "dbPurgeInterval": 86400000  // (24 hours) Time interval, in milliseconds, for executing process to purge database (delete oldest fees docs/recs)
  },
  // Parameter pertaining to BitcoinCoreFees module
  bitcoinCoreFees: {
    getFeeRatesInterval: 900000,  // (15 min.) Time interval, in milliseconds, for executing method to get current bitcoin fee rates
    initMonitorBlocksToConfirm: [  // List of initial target blocks to confirm for which fee rates should be monitored (periodically get current fee rates)
      2,    // Minimum number of blocks returned by Bitcoin Core's estimate fee RPC method
      30    // Number of blocks expected to confirm Catenis message transactions (300 min. -> 30 blocks)
    ]
  },
  // Parameters pertaining to BitcoinTicker module
  bitcoinTicker: {
    mainImplementation: 'bitcoinAverage',  // Name of bitcoin ticker implementation that should be normally used over the others (the backup ones)
    minCheckRevertMainInstanceTimeout: 300000,  // (5 min.) Minimum time, in milliseconds, to wait before trying to revert back to using main bitcoin ticker implementation instance
    maxCheckRevertMainInstanceTimeout: 86400000  // (24 hours) Minimum time, in milliseconds, to wait before trying to revert back to using main bitcoin ticker implementation instance
  },
  // Parameters pertaining to BitcoinAverageBitcoinTicker module
  bitcoinAverageBitcoinTicker: {
    apiUrl: "https://apiv2.bitcoinaverage.com/indices/global/",  // URL of API (from BitcoinAverage) used to retrieve current market info on different crypto currencies
    bitcoinTickerEndPoint: "ticker/short?crypto=BTC&fiat=USD",  // API endpoint used to retrieve bitcoin market price
    apiKey: "?????",  // (optional, can be set to null) Base64 encoded, ciphered public key of the API key pair provided by the service (required for certain API services)
    localAddress: null,  // (optional, can be set to null) IP address of local network interface to use to issue requests to the Web service
    timeout: 20000  // (20 sec.) Timeout, in milliseconds, for connection/request with API server
  },
  // Parameters pertaining to GeminiBitcoinTicker module
  geminiBitcoinTicker: {
    apiUrl: "https://api.gemini.com/",  // URL of API (from Gemini) used to retrieve current market info on different crypto currencies
    bitcoinTickerEndPoint: "v1/pubticker/btcusd",  // API endpoint used to retrieve bitcoin market price
    localAddress: null,  // (optional, can be set to null) IP address of local network interface to use to issue requests to the Web service
    timeout: 20000  // (20 sec.) Timeout, in milliseconds, for connection/request with API server
  },
  // Parameters pertaining to BitcoinPrice module
  "bitcoinPrice": {
    "priceChangeTimeInterval": 5000,  // (5 sec.) Time interval, in milliseconds, used to detect when bitcoin ticker price changes
    "updatePriceTimeInterval": 300000,  // (5 min.) Time interval, in milliseconds, for retrieving new bitcoin ticker price
    "purgeTimeInterval": 86400000,  // (24 hours) Time interval, in milliseconds, for purging older bitcoin ticker prices
    "priceMaximumLifeTime": 2592000000  // (30 days) Time, in milliseconds, corresponding to maximum life time of recorded bitcoin ticker price. Older prices shall be purged
  },
  // Parameters pertaining to KeyStore module
  "keyStore": {
    "obsoleteExtKeyTimeToPurge": 345600,  // (4 days) Time, in seconds, before an obsolete HD extended key is purged from local key storage
    "purgeUnusedExtKeyInterval": 43200000,  // (12 hours) Time interval, in milliseconds, for executing method to purge unused HD extended keys form local key storage
    legacyEncryptScheme: []
  },
  // Parameters pertaining to BitcoinCore module
  "bitcoinCore": {
    "serverHost": "catenis-btccore", // Bitcoin Core server host name/IP address
    "mainRpcPort": 8332, // Port used to connect with Bitcoin Core server via its RPC interface to interact with bitcoin's main blockchain
    "testnetRpcPort": 18332, // Port used to connect with Bitcoin Core server via its RPC interface to interact with bitcoin's testnet blockchain
    "rpcUser": "??????", // Username used to connect with Bitcoin Core server via its RPC interface
    "rpcPassword": "??????", // Password used to connect with Bitcoin Core server via its RPC interface
    "rpcConnectionTimeout": 15000,  // (15 sec.) Timeout, in milliseconds, for RPC connection with the Bitcoin Core server
    "rescanTimeout": 7200000 // (2 hours) Timeout, in milliseconds, for waiting on Bitcoin Core to finish rescanning the blockchain after importing private key
  },
  // Parameters pertaining to OmniCore module
  "omniCore": {
    "serverHost": "catenis-omncore", // Omni Core server host name/IP address
    "mainRpcPort": 8332, // Port used to connect with Omni Core server via its RPC interface to interact with bitcoin's main blockchain
    "testnetRpcPort": 18332, // Port used to connect with Omni Core server via its RPC interface to interact with bitcoin's testnet blockchain
    "rpcUser": "??????", // Username used to connect with Omni Core server via its RPC interface
    "rpcPassword": "??????", // Password used to connect with Omni Core server via its RPC interface
    "rpcConnectionTimeout": 15000,  // (15 sec.) Timeout, in milliseconds, for RPC connection with the Omni Core server
    "rescanTimeout": 7200000 // (2 hours) Timeout, in milliseconds, for waiting on Omni Core to finish rescanning the blockchain after importing private key
  },
  // Parameters pertaining to BaseBlockchainAddress module
  "baseBlockchainAddress": {
    "addressValidity": {  // Time, in seconds, before which a newly issued address expires
      "systemDeviceMain": 900,  // (15 min.)
      "systemFundingPayment":  14400,  // (4 hours)
      "systemFundingChange": 900,  // (15 min.)
      "systemPayTxExpense": 900,  // (15 min.)
      "systemReadConfSpendNotify": 900,  // (15 min.)
      "systemReadConfSpendOnly": 900,  // (15 min.)
      "systemReadConfSpendNull": 900,  // (15 min.)
      "systemReadConfPayTxExpense": 900,  // (15 min.)
      "systemServCredIssuing": 0,  // Indicates that addresses of this type should never expire
      "systemServPymtPayTxExpense": 900,  // (15 min.)
      "systemMultiSigSignee": 900,  // (15 min.)
      "systemBcotSaleStock": 0,  // Indicates that addresses of this type should never expire
      "systemOCMsgsSetlmtPayTxExpense": 900,  // (15 min.)
      "clientServAccCreditLine": 900,  // (15 min.)
      "clientServAccDebitLine": 900,  // (15 min.)
      "clientBcotPayment": 14400,  // (4 hours)
      "deviceReadConfirm": 900,  // (15 min.)
      "deviceMigratedAsset": 900,  // (15 min.)
      "deviceMain": 900,  // (15 min.)
      "deviceAsset": 900,  // (15 min.)
      "deviceAssetIssuance": 900  // (15 min.)
    },
    "updateIssuedAddressesInterval": 7200000, // (2 hours) Time interval, in milliseconds, for executing method to update issued addresses
    "inactiveObjectTime": 345600,  // (4 days) Time, in seconds, from the time when instantiated object has been last accessed before it is considered inactive
    "deleteInactiveObjectsInterval": 43200000 // (12 hours) Time interval, in milliseconds, for executing method to delete inactive objects
  },
  // Parameters pertaining to BaseOffChainAddress module
  "baseOffChainAddress": {
    "inactiveObjectTime": 345600,  // (4 days) Time, in seconds, from the time when instantiated object has been last accessed before it is considered inactive
    "deleteInactiveObjectsInterval": 43200000 // (12 hours) Time interval, in milliseconds, for executing method to delete inactive objects
  },
  // Parameters pertaining to FundSource module
  "fundSource": {
    "maxAncestorsCount": 25, // Maximum count of (unconfirmed) ancestor txs for tx to be accepted into mempool (to be relayed)
    "maxAncestorsSize": 101000,  // Maximum total virtual size (in vbytes) of (unconfirmed) ancestor txs for tx to be accepted into mempool (to be relayed)
    "maxDescendantsCount": 25, // Maximum count of (unconfirmed) descendant txs for tx to be accepted into mempool (to be relayed)
    "maxDescendantsSize": 101000  // Maximum total virtual size (in vbytes) of (unconfirmed) descendant txs for tx to be accepted into mempool (to be relayed)
  },
  // Parameters pertaining to Service module
  "service": {
    "priceMarkup": 0.35,  // Markup used to calculate the service price
    "servicePriceResolution": 100,  // Resolution of service prices. In other words, the price of the services (expressed in Catenis service credit's lowest units) should be a multiple of that value
    "paymentResolution": 10,  // Resolution of amount, in satoshis, that should be allocated to pay for tx expenses. In other words, the allocated amount should be a multiple of that amount
    "maxNumAddrsPerFundingTx": 170,  // Maximum number of funding addresses that should be allocated for a single funding transaction
    "systemFunding": {
      "clientsToFund": 10,  // Number of clients to consider when calculating total amount to fund
      "devicesPerClientToFund": 10,  // Number of devices per client to consider when calculating total amount to fund
      "multiplyFactor": 2  // Multiply factor to use when calculating total amount to fund
    },
    "serviceCreditIssueAddrFunding": {
      // NOTE: unitAmount (amount, in satoshis, equivalent to one unit of funding) is dynamically calculated: `serviceCreditIssuanceAddrAmount` getter property
      "maxUnitsPerUtxo": 2,  // Maximum number of units of funding that should be accumulated into a single UTXO
      "minUtxosToFund": 10,  // Number of UTXOs that should be funded before start accumulating funding units into a single UTXO
      "unitsPerPrePaidClients": 0.1,  // Expected number of units of funding that there should exist per pre-paid clients
      "unitsPerPostPaidClients": 0.1,  // Expected number of units of funding that there should exist per post-paid clients
      "prePaidClientsToFund": 100,  // Number of pre-paid clients to consider when calculating total amount to fund
      "postPaidClientsToFund": 100  // Number of post-paid clients to consider when calculating total amount to fund
    },
    "bcotSaleStockAddrFunding": {
      // NOTE: unitAmount (amount, in satoshis, equivalent to one unit of funding) is dynamically calculated: `bcotSaleStockAddrAmount` getter property
      "maxUnitsPerUtxo": 2,  // Maximum number of units of funding that should be accumulated into a single UTXO
      "minUtxosToFund": 10,  // Number of UTXOs that should be funded before start accumulating funding units into a single UTXO
      "unitsPerPrePaidClients": 0.1,  // Expected number of units of funding that there should exist per pre-paid clients
      "unitsPerPostPaidClients": 0.1,  // Expected number of units of funding that there should exist per post-paid clients
      "prePaidClientsToFund": 100,  // Number of pre-paid clients to consider when calculating total amount to fund
      "postPaidClientsToFund": 100  // Number of post-paid clients to consider when calculating total amount to fund
    },
    "serviceAccountFunding": {
      // NOTE: unitAmount (amount, in Catenis service credit's lowest unit, equivalent to one unit of funding) is dynamically calculated: `serviceCreditIssuanceAddrAmount` getter property
      "unitAmountSafetyFactor": 0.3,  // Safety factor to use when calculating funding unit amount
      "maxUnitsPerAddr": 100,  // Maximum number of units of funding that should be accumulated into a single UTXO/address (there should be a single UTXO per address)
      "minAddrsToFund": 4  // Number of UTXOs/addresses that should be funded before start accumulating funding units into a single UTXO/address (there should be a single UTXO per address)
    },
    "payTxExpenseFunding": {
      // NOTE: unitAmount (amount, in satoshis, equivalent to one unit of funding) is dynamically calculated: `payTxExpFundUnitAmount` getter property
      "unitAmountSafetyFactor": 0.3,  // Safety factor to use when calculating funding unit amount
      "maxUnitsPerAddr": 10,  // Maximum number of units of funding that should be accumulated into a single UTXO/address (there should be a single UTXO per address)
      "minAddrsToFund": 10,  // Number of UTXOs/addresses that should be funded before start accumulating funding units into a single UTXO/address (there should be a single UTXO per address)
      "balanceSafetyFactor": 0.15, // Safety factor to use when calculating balance
      "minBalanceSysMessages": 30,  // Number of messages that system can send used to calculate minimum balance threshold
      "minBalanceServicesPerDevice": 30,  // Number of services a device can consume used to calculate minimum balance threshold
      "sysMessagesToFund": 10,  // Number of messages that system can send to consider when calculating total amount to fund
      "devicesToFund": 10  // Number of devices to consider when calculating total amount to fund
    },
    "readConfirmPayTxExpenseFunding": {
      // NOTE: unitAmount (amount, in satoshis, equivalent to one unit of funding) is dynamically calculated: `readConfirmPayTxExpFundUnitAmount` getter property
      "unitAmountSafetyFactor": 0,  // Safety factor to use when calculating funding unit amount
      "maxUnitsPerAddr": 10,  // Maximum number of units of funding that should be accumulated into a single UTXO/address (there should be a single UTXO per address)
      "minAddrsToFund": 10,  // Number of UTXOs/addresses that should be funded before start accumulating funding units into a single UTXO/address (there should be a single UTXO per address)
      "balanceSafetyFactor": 0.15, // Safety factor to use when calculating balance
      "minBalanceMessagesToConfirm": 50,  // Number of messages to confirm used to calculate minimum balance threshold
      "messagesToConfirmToFund": 100  // Number of messages to confirm to consider when calculating total amount to fund
    },
    "servicePaymentPayTxExpenseFunding": {
      // NOTE: unitAmount (amount, in satoshis, equivalent to one unit of funding) is dynamically calculated: `servicePaymentPayTxExpFundUnitAmount` getter property
      "unitAmountSafetyFactor": 0,  // Safety factor to use when calculating funding unit amount
      "maxUnitsPerAddr": 50,  // Maximum number of units of funding that should be accumulated into a single UTXO/address (there should be a single UTXO per address)
      "minAddrsToFund": 10,  // Number of UTXOs/addresses that should be funded before start accumulating funding units into a single UTXO/address (there should be a single UTXO per address)
      "balanceSafetyFactor": 0.15, // Safety factor to use when calculating balance
      "minBalancePrePaidServices": 50,  // Number of services to be pre-paid used to calculate minimum balance threshold
      "minBalancePostPaidServices": 100,  // Number of services to be post-paid used to calculate minimum balance threshold
      "servicesToPayToFund": 300  // Number of services to pay to consider when calculating total amount to fund
    },
    "ocMsgsSettlementPayTxExpenseFunding": {
      // NOTE: unitAmount (amount, in satoshis, equivalent to one unit of funding) is dynamically calculated: `ocMsgsSetlmtPayTxExpFundUnitAmount` getter property
      "unitAmountSafetyFactor": 0.3,  // Safety factor to use when calculating funding unit amount
      "maxUnitsPerAddr": 5,  // Maximum number of units of funding that should be accumulated into a single UTXO/address (there should be a single UTXO per address)
      "minAddrsToFund": 5,  // Number of UTXOs/addresses that should be funded before start accumulating funding units into a single UTXO/address (there should be a single UTXO per address)
      "balanceSafetyFactor": 0.15, // Safety factor to use when calculating balance
      "minBalanceSettlementCycles": 5,  // Number of Catenis off-chain messages settlement cycles used to calculate minimum balance threshold
      "settlementCyclesToFund": 100  // Number of Catenis off-chain messages settlement cycles to consider when calculating total amount to fund
    },
    "servicePayment": {
      "paymentResolution": 10,  // Resolution of amount, in satoshis, that should be allocated to pay for the expenses of transactions related to service payment. In other words, the allocated amount should be a multiple of this amount
      // To be used with pre-paid clients
      "spendServiceCredit": {
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "initNumTxWitnessInputs": 2,            // Initial number of segregated witness inputs of a spend service credit transaction (1 client service account credit line, 1 service payment pay tx expense)
        "initNumTxNonWitnessInputs": 0,         // Initial number of non-segregated witness inputs of a spend service credit transaction
        "initNumTxWitnessOutputs": 2,           // Initial number of segregated witness outputs of a spend service credit transaction (1 client service account credit line change, 1 service payment pay tx expense change)
        "initNumTxNonWitnessOutputs": 0,        // Initial number of non-segregated witness outputs of a spend service credit transaction
        "initNumPubKeysMultiSigTxOutputs": [],  // List with initial number of public keys per multi-signatures outputs in spend service credit transaction
        "txNullDataPayloadSize": 80,            // Size, in bytes, of payload of null data output in spend service credit transaction
        "maxNumClients": 12,  // Maximum number of clients for which services are paid in a spend service credit transaction
        "servsDistribPerClient": 2,  // Number of services that should be assigned to same client before proceeding to next client
        "maxServsPerClientInput": 25,  // Maximum number of services that can be paid for each client service account credit line address input
        "numClientsMultiSigOutput": 4,  // Required number of clients for (the only) multi-signature output to be added to spend service credit transaction
        "percMaxUnitsPayTxExp": 0.4,  // Percentage of max units per pay tx expense address input that should be considered available
        "initTxFeeRate": 1,  // Amount, in satoshis/byte, for the initial fee rate for a spend service credit transaction
        "txFeeRateIncrement": 1  // Amount, in satoshis/byte, that transaction feed rate should be incremented for the new replacement transaction
      },
      // To be used with post-paid clients
      "debitServiceAccount": {
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "initNumTxWitnessInputs": 2,            // Initial number of segregated witness inputs of a debit service account transaction (1 service credit issuance, 1 service payment pay tx expense)
        "initNumTxNonWitnessInputs": 0,         // Initial number of non-segregated witness inputs of a debit service account transaction
        "initNumTxWitnessOutputs": 4,           // Initial number of segregated witness outputs of a debit service account transaction (1 client service account debit line, 1 service credit issuance refund, 1 service credit issuance change, 1 service payment pay tx expense change)
        "initNumTxNonWitnessOutputs": 0,        // Initial number of non-segregated witness outputs of a debit service account transaction
        "initNumPubKeysMultiSigTxOutputs": [],  // List with initial number of public keys per multi-signatures outputs in debit service account transaction
        "txNullDataPayloadSize": 80,            // Size, in bytes, of payload of null data output in debit service account transaction
        "maxNumClients": 11,  // Maximum number of clients for which services are paid in a debit service account transaction
        "servsDistribPerClient": 2,  // Number of services that should be assigned to same client before proceeding to next client
        "numClientsMultiSigOutput": 4,  // Required number of clients for (the only) multi-signature output to be added to debit service account transaction
        "percMaxUnitsPayTxExp": 0.5,  // Percentage of max units per pay tx expense address input that should be considered available
        "initTxFeeRate": 1,  // Amount, in satoshis/byte, for the initial fee rate for a debit service account transaction
        "txFeeRateIncrement": 1  // Amount, in satoshis/byte, that transaction feed rate should be incremented for the new replacement transaction
      }
    },
    "sysMessage": {
      "messagesPerMinute": 4,  // Number of system messages sent per minute that is expected to be sustained
      "minutesToConfirm": 300,  // (5 hours) Time, in minutes, within which send system message txs are expected to be confirmed
      "unconfMainAddrReuses": 10,  // Number of times an UTXO associated with a system main addr is expected to be reused
      "mainAddrFunding": {
        // NOTE: unitAmount (amount, in satoshis, equivalent to one unit of funding) is dynamically calculated: `sysDevMainAddrAmount` getter property
        "maxUnitsPerAddr": 10,  // Maximum number of units of funding that should be accumulated into a single UTXO/address (there should be a single UTXO per address)
        "minAddrsToFund": 10  // Number of UTXOs/addresses that should be funded before start accumulating funding units into a single UTXO/address (there should be a single UTXO per address)
      },
      "offChainMessagesSettlement": {
        "minutesToConfirm": 300  // (5 hours) Time, in minutes, within which settle off-chain messages txs are expected to be confirmed.
                                 //  NOTE: can be set to NULL to indicate that the optimum fee rate (lowest fee for fastest confirmation) should be used
      }
    },
    "sysTxConfig": {
      "sendSysMessage": {  // Send system message transaction
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "numWitnessInputs": 3,      // Number of segregated witness inputs (that spend P2WPKH outputs)
        "numNonWitnessInputs": 0,   // Number of non-segregated witness inputs (that spend P2PKH outputs)
        "numWitnessOutputs": 3,     // Number of segregated witness (P2WPKH) outputs
        "numNonWitnessOutputs": 0,  // Number of non-segregated witness (P2PKH) outputs
        "nullDataPayloadSize": 80 // Size, in bytes, of payload of null data output
      },
      "settleOffChainMessages": {  // Settle off-chain messages
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "numWitnessInputs": 2,      // Number of segregated witness inputs (that spend P2WPKH outputs)
        "numNonWitnessInputs": 0,   // Number of non-segregated witness inputs (that spend P2PKH outputs)
        "numWitnessOutputs": 1,     // Number of segregated witness (P2WPKH) outputs
        "numNonWitnessOutputs": 0,  // Number of non-segregated witness (P2PKH) outputs
        "nullDataPayloadSize": 39 // Size, in bytes, of payload of null data output
      }
    },
    "message": {
      "messagesPerMinute": 4,  // Number of messages sent per minute that is expected to be sustained
      "minutesToConfirm": 300,  // (5 hours) Time, in minutes, within which send message txs are expected to be confirmed
      "unconfMainAddrReuses": 10,  // Number of times an UTXO associated with a device main addr is expected to be reused
      // NOTE: readConfirmAddrAmount (amount, in satoshis, that should be paid to read confirmation address output of send message tx) is dynamically calculated: `devReadConfirmAddrAmount` getter property
      "mainAddrFunding": {
        // NOTE: unitAmount (amount, in satoshis, equivalent to one unit of funding) is dynamically calculated: `devMainAddrAmount` getter property
        "maxUnitsPerAddr": 10,  // Maximum number of units of funding that should be accumulated into a single UTXO/address (there should be a single UTXO per address)
        "minAddrsToFund": 10  // Number of UTXOs/addresses that should be funded before start accumulating funding units into a single UTXO/address (there should be a single UTXO per address)
      },
      "readConfirmation": {
        "paymentResolution": 10,  // Resolution of amount, in satoshis, that should be allocated to pay for read confirmation tx expenses. In other words, the allocated amount should be a multiple of this amount
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "initNumTxWitnessInputs": 2,      // Initial number of segregated witness inputs of a read confirmation transaction (1 to spend a read confirmation output, 1 to pay for tx expense)
        "initNumTxNonWitnessInputs": 0,   // Initial number of non-segregated witness inputs of a read confirmation transaction
        "initNumTxWitnessOutputs": 2,     // Initial number of segregated witness outputs of a read confirmation transaction (1 to receive payment of read confirmation output spent, 1 to receive change)
        "initNumTxNonWitnessOutputs": 0,  // Initial number of non-segregated witness outputs of a read confirmation transaction
        "txNullDataPayloadSize": 0,       // Size, in bytes, of payload of null data output in read confirmation transaction
        "txInputOutputGrowthRatio": 10, // Number representing how many additional inputs needs to be added to the a read confirmation tx for a new output to be added
                                        // NOTE: these additional outputs should account for read confirmation outputs spent to notify devices that belong to a different Catenis node
        "percMaxUnitsPayTxExp": 0.5,  // Percentage of max units per pay tx expense address input that should be considered available
        "initTxFeeRate": 1,  // Amount, in satoshis/byte, for the initial fee rate for a read confirmation transaction
        "txFeeRateIncrement": 1,  // Amount, in satoshis/byte, that transaction feed rate should be incremented for the new replacement transaction
        "terminalReadConfirmTx": {
          "minutesToConfirm": 300,  // (5 hours) Time, in minutes, within which terminal read confirmation txs are expected to be confirmed
          "typicalTxConfig": {
            "numMessagesConfirmed": 2,  // Number of send message txs confirmed by terminal read confirmation transactions
            "numPayTxExpenseInputs": 2,  // Number of inputs used to pay for tx expense (fee)
            "hasChangeOutput": true, // Indicates whether tx includes an output for receiving change
            "nullDataPayloadSize": 0  // Size, in bytes, of payload of null data output
          }
        },
        "usageWeight": {
          "regular": 1,   // Regular read confirmation tx (using RBF) usage weight
          "terminal": 10  // Terminal read confirmation tx usage weight
        }
      },
      "offChain": {
        "price": {
          "numMsgsPayCost": 40,  // Number of off-chain messages required to pay for full cost of settle off-chain messages transaction
          "msgReceipt": {
            "percCost": 0.25  // (25%) Percentage of off-chain message cost that shall be charged for off-chain message receipts
          }
        }
      }
    },
    "asset": {
      "issuance": {
        "assetsPerMinute": 1,  // Number of assets issued per minute that is expected to be sustained
        "minutesToConfirm": 300,  // (5 hours) Time, in minutes, within which asset issuance txs are expected to be confirmed
        "unconfAssetIssueAddrReuses": 10,  // Number of times an UTXO associated with a device asset issuance addr is expected to be reused
        "assetIssueAddrFunding": {
          // NOTE: unitAmount (amount, in satoshis, equivalent to one unit of funding) is dynamically calculated: `devAssetIssuanceAddrAmount` getter property
          "maxUnitsPerAddr": 10,  // Maximum number of units of funding that should be accumulated into a single UTXO/address (there should be a single UTXO per address)
          "minAddrsToFund": 10  // Number of UTXOs/addresses that should be funded before start accumulating funding units into a single UTXO/address (there should be a single UTXO per address)
        }
      },
      "transfer": {
        "minutesToConfirm": 300  // (5 hours) Time, in minutes, within which transfer asset txs are expected to be confirmed
      },
      "outMigrate": {
        "minutesToConfirm": 300  // (5 hours) Time, in minutes, within which out-migrate asset txs are expected to be confirmed
      },
      "inMigrate": {
        "minutesToConfirm": 300  // (5 hours) Time, in minutes, within which in-migrate asset txs are expected to be confirmed
      }
    },
    "serviceTxConfig": {
      "logMessage": {  // Log message
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "numWitnessInputs": 3,      // Number of segregated witness inputs (that spend P2WPKH outputs)
        "numNonWitnessInputs": 0,   // Number of non-segregated witness inputs (that spend P2PKH outputs)
        "numWitnessOutputs": 2,     // Number of segregated witness (P2WPKH) outputs
        "numNonWitnessOutputs": 0,  // Number of non-segregated witness (P2PKH) outputs
        "nullDataPayloadSize": 80   // Size, in bytes, of payload of null data output
      },
      "sendMessage": {  // Send message (without read confirmation)
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "numWitnessInputs": 3,      // Number of segregated witness inputs (that spend P2WPKH outputs)
        "numNonWitnessInputs": 0,   // Number of non-segregated witness inputs (that spend P2PKH outputs)
        "numWitnessOutputs": 3,     // Number of segregated witness (P2WPKH) outputs
        "numNonWitnessOutputs": 0,  // Number of non-segregated witness (P2PKH) outputs
        "nullDataPayloadSize": 80   // Size, in bytes, of payload of null data output
      },
      "sendMsgReadConfirm": {  // Send message with read confirmation
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "numWitnessInputs": 3,      // Number of segregated witness inputs (that spend P2WPKH outputs)
        "numNonWitnessInputs": 0,   // Number of non-segregated witness inputs (that spend P2PKH outputs)
        "numWitnessOutputs": 4,     // Number of segregated witness (P2WPKH) outputs
        "numNonWitnessOutputs": 0,  // Number of non-segregated witness (P2PKH) outputs
        "nullDataPayloadSize": 80   // Size, in bytes, of payload of null data output
      },
      "issueAsset": {  // Issue asset
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "numWitnessInputs": 3,      // Number of segregated witness inputs (that spend P2WPKH outputs)
        "numNonWitnessInputs": 0,   // Number of non-segregated witness inputs (that spend P2PKH outputs)
        "numWitnessOutputs": 4,     // Number of segregated witness (P2WPKH) outputs
        "numNonWitnessOutputs": 0,  // Number of non-segregated witness (P2PKH) outputs
        "nullDataPayloadSize": 68   // Size, in bytes, of payload of null data output
      },
      "transferAsset": {  // Transfer asset
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "numWitnessInputs": 4,      // Number of segregated witness inputs (that spend P2WPKH outputs)
        "numNonWitnessInputs": 0,   // Number of non-segregated witness inputs (that spend P2PKH outputs)
        "numWitnessOutputs": 3,     // Number of segregated witness (P2WPKH) outputs
        "numNonWitnessOutputs": 0,  // Number of non-segregated witness (P2PKH) outputs
        "nullDataPayloadSize": 10   // Size, in bytes, of payload of null data output
      },
      "outMigrateAsset": {  // Out-migrate asset
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "numWitnessInputs": 4,      // Number of segregated witness inputs (that spend P2WPKH outputs)
        "numNonWitnessInputs": 0,   // Number of non-segregated witness inputs (that spend P2PKH outputs)
        "numWitnessOutputs": 3,     // Number of segregated witness (P2WPKH) outputs
        "numNonWitnessOutputs": 0,  // Number of non-segregated witness (P2PKH) outputs
        "nullDataPayloadSize": 10   // Size, in bytes, of payload of null data output
      },
      "inMigrateAsset": {  // In-migrate asset
        // NOTE: the parameters below (next 4 lines) are for the best case where only segregated witness inputs and outputs are used (which is true in the long run for the sandbox environment and should be true for the production environment from inception)
        "numWitnessInputs": 4,      // Number of segregated witness inputs (that spend P2WPKH outputs)
        "numNonWitnessInputs": 0,   // Number of non-segregated witness inputs (that spend P2PKH outputs)
        "numWitnessOutputs": 3,     // Number of segregated witness (P2WPKH) outputs
        "numNonWitnessOutputs": 0,  // Number of non-segregated witness (P2PKH) outputs
        "nullDataPayloadSize": 10   // Size, in bytes, of payload of null data output
      }
    },
    "serviceUsageWeight": {
      "logMessage": 9,                  // Log message usage weight
      "sendMessage": 9,                 // Send message (without read confirmation) usage weight
      "sendMsgReadConfirm": 9,          // Send message with read confirmation usage weight
      "logOffChainMessage": 91,         // Log off-chain message usage weight
      "sendOffChainMessage": 91,        // Send off-chain message (without read confirmation) usage weight
      "sendOffChainMsgReadConfirm": 91, // Send off-chain message with read confirmation usage weight
      "issueAsset": 10,                 // Issue asset usage weight
      "transferAsset": 90,              // Transfer asset usage weight
      "outMigrateAsset": 7,             // Migrate asset usage weight
      "inMigrateAsset": 3               // Migrate asset usage weight
    }
  },
  // Parameters pertaining to BalanceInfo module
  "balanceInfo": {
    "defaultSafetyFactor": 0.1     // Safety factor used to check whether current balance is enough to cover current expect balance
  },
  // Parameters pertaining to CatenisNode module
  "catenisNode": {
    idPrefix: 'ctn-node',
    "serviceCreditAsset": {
      "nameFormat": "Catenis Service Credit - %s%s",
      "descriptionFormat": "Internal Catenis token used to pay for services consumed by devices of clients assigned to %s",
      "issuingOpts": {
        "type": "unlocked", // Issuing type of asset
        "divisibility": 7,  // Number of decimal places allowed for representing quantities of this asset
        "isAggregatable": true  // Indicates whether quantities of the asset from different UTXOs can be combined to allocate the necessary fund
      }
    }
  },
  // Parameters pertaining to Client module
  "client": {
    "firstAccountNumber": 1001,  // Number to be used when generating the very first client account number if no one still exists
    "userNamePrefix": "User for Catenis client",  // Prefix to be used for the name of users created to be associated with a Catenis clients
    "clientRole": "ctn-client",  // Role attributed to users associated with Catenis clients
    "minLicenseValidityDays": 7,  // Minimum number of days for a license validity period (when overriding the default validity period)
                           //  Note: this value must be kept in sync with the minValidityDays constant defined in the ClientLicensesTemplate.js module
    "minLicenseValDaysToReplace": 2,  // Minimum validity in days for a new license to replace an existing license
    "temporaryLicense": {  // Used to avoid that client devices be disabled for clients created before the license feature was available before an official license is assigned to them
      "active": false,   // Indicate that temporary license should be assigned
      "level": "Basic",  // Level of temporary license to assign
      "type": "annual"  // Type of temporary license to assign
    },
    creditsConsumption: {
      pastConsumptionPeriod: 86400,  // (24 hours) Time interval, in seconds, to consider when computing past credits consumption
      minimumBalanceMultiplyFactor: 1,  // Multiplication factor (over the computed past credits consumption) to be used for calculating the suggested minimum service account balance
      balanceFloorMultiplyFactor: 1,  // Multiplication factor (over Catenis' highest service price) to be used for calculating the floor value of the service account balance
      timeToLowBalanceRenotification: 24,  // (24 hours) Time, in hours, after which another UI/e-mail notification message warning the client that the service account balance is too low can be displayed/sent
      servAccBalanceInfoUIRefreshTimeout: 900000,  // (15 min.) Timeout, in milliseconds, after which service account balance info should be checked if it needs to be updated on the UI. Set to 0 (zero) to disable it
    },
    // NOTE: the following should be interpreted as a single entry with an object value
    "deviceDefaultRightsByEvent": {   // Default permission right settings for newly created devices to be assigned to clients: there must be one entry for each defined permission event
      "receive-notify-new-msg": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "allow": "self"
        }
      },
      "receive-notify-msg-read": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "deny": "self"
        }
      },
      "receive-notify-asset-of": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "deny": "self"
        }
      },
      "receive-notify-asset-from": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "deny": "self"
        }
      },
      "receive-notify-confirm-asset-of": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "allow": "self"
        }
      },
      "receive-notify-confirm-asset-from": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "allow": "self"
        }
      },
      "send-read-msg-confirm": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "deny": "self"
        }
      },
      "receive-msg": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "allow": "self"
        }
      },
      "disclose-main-props": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "allow": "self"
        }
      },
      "disclose-identity-info": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "allow": "self"
        }
      },
      "receive-asset-of": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "allow": "self"
        }
      },
      "receive-asset-from": {
        "system": "deny",
        "client": {
          "allow": "self"
        },
        "device": {
          "allow": "self"
        }
      }
    }
  },
  // Parameters pertaining to Transaction module
  "transaction": {
    witnessOutputDustAmount: 294,  // Minimum amount that should be allocated to a segregated witness (P2WPKH) tx output: (<output_size> + <input_size>) * <dust_relay_fee>/1000 => (34+148)*3000/1000 = 294 satoshis/KB
    nonWitnessOutputDustAmount: 546,  // Minimum amount that should be allocated to a non-segregated witness (P2PKH) tx output: (<output_size> + <input_size>) * <dust_relay_fee>/1000 => (31+67)*3000/1000 = 546 satoshis/KB
    legacyDustAmount: 600,  // Amount that was used by Catenis as the dust amount: rounded up non-segregated witness output dust amount
    "maxTxVsize": 100000,  // Maximum virtual size, in vbytes, of a transaction that is considered valid
    "pubKeySize": 33,  // Size, in bytes, of blockchain key-pair public key
    "oneOf2MultiSigTxOutputDustAmount": 700,  // Minimum amount that should be allocated to a 1-of-2 multisig transaction output - (<output_size> + 148) * <dust_relay_fee>/1000 => (80+148)*3000/1000 = 684 satoshis/kb ~ 700
    "oneOf3multiSigTxOutputDustAmount": 800  // Minimum amount that should be allocated to a 1-of-3 multisig transaction output - (<output_size> + 148) * <dust_relay_fee>/1000 => (114+148)*3000/1000 = 786 satoshis/kb ~ 800
  },
  // Parameters pertaining to TransactionMonitor module
  "transactionMonitor": {
    "blockchainPollingInterval": 15000, // (15 sec.) Time interval, in milliseconds, for polling the blockchain for newly arrived transactions and blocks
    "mempoolExpiryHours": 336,  // (14 days) Time, in hours, after which transactions are evicted from Bitcoin Core' mempool
    "purgeFoundNewCtnTxsInterval": 3600000,  // (1 hour) Time interval, in milliseconds, for executing method to purge transactions from list of found new Catenis transactions
    "limitTxConfirmTime": 360,  // (6 hour) Time, in minutes, after which it is expected for any Catenis issued transaction to have already been confirmed
    "checkOldUnconfTxsInterval": 1800000,  // (30 min.) Time interval, in milliseconds, for checking if there are old transactions that have not yet been confirmed
    checkOldUnconfTxsDelay: 300000,  // (5 min.) Time, in milliseconds, to wait before checking if there are old transactions that have not yet been confirmed
    blocksBehindToFixUnconfTxs: 2,  // Number of blocks that old unconfirmed transactions should have been confirmed for they to be fixed
    "newTxsBatchProcDoneTimeout": 60000  // (1 min.) Timeout, in milliseconds, for waiting for a given new transactions batch to finish processing
  },
  // Parameters pertaining to CatenisMessage module
  "catenisMessage": {
    "nullDataMaxSize": 80,  // Maximum size, in bytes, of data that fits in null data output
    "defaultStorageProvider": "ipfs"
  },
  // Parameters pertaining to IpfsClient module
  "ipfsClient": {
    "apiHost": "catenis-ipfs",
    "apiPort": 5001,
    "apiProtocol": "http"
  },
  // Parameters pertaining to IpfsClusterClient module
  "ipfsClusterClient": {
    "apiUrl": "http://catenis-ipfs:9094/",  // URL of IPFS Cluster REST API
    "localAddress": null,  // (optional, can be set to null) IP address of local network interface to use to connect to the IPFS Cluster RESP API. If not specified, the default network interface is used
    "timeout": 20000  // (20 sec.) (optional, can be set to null) Timeout, in milliseconds, for connection/request with API server
  },
  // Parameters pertaining to IpfsServerMonitor module
  "ipfsServerMonitor": {
    "enabled": true,
    "ipfsCluster": {
      "inUse": false,  // Indicates whether IPFS Cluster in being used
      "numberOfPeers": 0  // Expected number of active IPFS Cluster nodes
    },
    "checkInterval": 300  // (5 min.) Time, in seconds, defining the period within which IPFS server shall be checked to make sure it is still alive
  },
  // Parameters pertaining to Message module
  "message": {
    "maxQueryCount": 500,  // Maximum number of messages entries that can be returned when querying for messages
    "minSizeReadDataChunk": 1024,  // (1 KB) Minimum size, in bytes, of data chunks that should be used when reading message in chunks
    "maxSizeReadDataChunk": 15728640  // (15 MB) Maximum size, in bytes, of data chunks that should be used when reading message in chunks
                                      //  Note: this must be below 16 MB, which is the maximum size of a MongoDB doc/rec, since the whole data chunk is stored in a single database doc/rec (of the MessageChunk collection)
  },
  // Parameters pertaining to RbfTransactionInfo module
  "rbfTransactionInfo": {
    "minDeltaFeeRate": 1  // Minimum difference in transaction fee rate, in satoshis per byte, that is allowed for a new transaction to replace a previously sent one
  },
  // Parameters pertaining to ReadConfirmation module
  "readConfirmation": {
    "unconfirmedTxTimeout": 10080,  // (7 days) Timeout, in minutes, for waiting for latest read confirmation tx to be confirmed (set to 7 days, which is half the default mempool tx eviction time of 14 days)
    "txSizeThresholdRatio": 0.9  // Ratio that should be applied to maximum tx size to calculate threshold for read confirmation tx size. Above that size the tx fee rate should be reset so that is is confirmed as soon as possible
  },
  // Parameters pertaining to RestApi module
  "restApi": {
    "rootPath": "api",
    "availableVersions": [    // List of all currently available versions of the Catenis REST API
      "0.2",
      "0.3",
      "0.4",
      "0.5",
      "0.6",
      "0.7",
      "0.8",
      "0.9",
      "0.10",
      "0.11"
    ]
  },
  // Parameters pertaining to Authentication module
  "authentication": {
    "httpRequestSignature": {
      "signVersionId": "CTN1",
      "signMethodId": "CTN1-HMAC-SHA256",
      "scopeRequest": "ctn1_request",
      "timestampHdr": "x-bcot-timestamp",
      "allowedTimestampOffset": 300,   // (5 min.) Time, in seconds, representing the allowed variation (+/-) of timestamp in regards to current time
                                       //  for request to be considered valid
      "authRegexPattern": "^<signMethodId> +(?:C|c)redential *= *(\\w{20})/(\\d{8})/<scopeRequest> *, *(?:S|s)ignature *= *([0-9a-fA-F]{64}) *$",
      "signValidDays": 7  // Number of days from specified signature date after which signature is not considered valid anymore
    }
  },
  // Parameters pertaining to Notification module
  "notification": {
    "notifyRootPath": "notify",  // Root path to be used for all notification message dispatcher based on the HTTP protocol.
                                //  NOTE: the Rest API root path (see restApi section above) plus the API version shall be prepended to this path to form the fully qualified notification root path
    "initVersion": "0.1",   // Initial version of the Catenis notification service
    "availableVersions": [{  // List of all currently available versions of the Catenis notification service with their respective Catenis API version
      "ver": "0.1",
      "apiVer": "0.4"
    }, {
      "ver": "0.2",
      "apiVer": "0.6"
    }, {
      "ver": "0.3",
      "apiVer": "0.7"
    }, {
      "ver": "0.4",
      "apiVer": "0.11"
    }]
  },
  // Parameters pertaining to WebSocketNotifyMsgDispatcher module
  "webSocketNotifyMsgDispatcher": {
    "wsNotifyRootPath": "ws",  // Root of all paths to be used as endpoints for establishing WebSocket connections for this notification message dispatcher.
                               //  NOTE: the fully qualified notification root path (see notification section above) shall be prepended to this path to form the qualified base URI path for this dispatcher
    "notifyWsSubprotocol": "notify.catenis.io",  // Name of WebSocket subprotocol to be used for dispatching notification messages
                                                 //  NOTE: it's a proprietary protocol that just sends the notification messages straight to the connected client as long as there is an open connection for the given notification event.
                                                 //    Thus the client needs to open one WebSocket connection for each notification event for which it wishes to receive notifications. There shall be an endpoint URI for each notification event
    "initVersion": "0.1",   // The initial version of the WebSocket notification message dispatcher
    "availableVersions": [{  // List of all currently available versions of the WebSocket notification message dispatcher with their respective Catenis API version
      "ver": "0.1",
      "apiVer": "0.4"
    }, {
      "ver": "0.2",
      "apiVer": "0.7"
    }],
    "heartbeatInterval": 30000,  // (30 sec.) Time interval, in milliseconds, for sending heartbeat ping package to client
    "authMsgTimeout": 5000,   // (5 sec.) Timeout, in milliseconds, for waiting on first message from client used to authenticate itself with the system
    "notifyChannelOpenMsg": "NOTIFICATION_CHANNEL_OPEN",  // Contents of message sent to client as a response to a valid initial authentication message to indicate that the notification channel is successfully open and is ready to send notifications
                                                          //  NOTE: this message is NOT sent by earlier versions of the WebSocket notification message dispatcher (see 'ntfyChnOpnMsgMinVer' config param below)
    "ntfyChnOpnMsgMinVer": "0.2"  // Minimal version of the WebSocket notification message dispatcher that will send the "notification channel open" response message
  },
  // Parameters pertaining to C3NodeClient module
  "c3NodeClient": {
    "serverHost": "catenis-c3nserv", // Catenis Colored Coins node server host name/IP address
    "mainTcpPort": 8033, // TCP port used to connect with the Catenis Colored Coins node server to interact with bitcoin's main blockchain
    "testnetTcpPort": 8043, // TCP port used to connect with the Catenis Colored Coins node server to interact with bitcoin's testnet blockchain
    "inetAddress": "", // IP address of local network interface to use to connect with the Catenis Colored Coins node server. If not specified (empty string) the default network interface is used
    "user": "??????", // Username used to authenticate the client to the Catenis Colored Coins node server. If not specified (empty string) assume that no authentication is required
    "password": "??????", // Password used to authenticate the client to the Catenis Colored Coins node server
    "connectionTimeout": 15000,  // (15 sec.) Timeout, in milliseconds, for connection with the Catenis Colored Coins node server
    "methodPath": {
      "parseNow": "/parseNow",
      "getAddressesUtxos": "/getAddressesUtxos",
      "getUtxos": "/getUtxos",
      "getTxouts": "/getTxouts",
      "getAddressesTransactions": "/getAddressesTransactions",
      "transmit": "/transmit",
      "getInfo": "/getInfo",
      "importAddresses": "/importAddresses",
      "getAssetHolders": "/getAssetHolders",
      "getAssetBalance": "/getAssetBalance",
      "getMultiAssetBalance": "/getMultiAssetBalance",
      "getAssetIssuance": "/getAssetIssuance",
      "getAssetIssuingAddress": "/getAssetIssuingAddress",
      "getOwningAssets": "/getOwningAssets"
    }
  },
  // Parameters pertaining to CCMetadata module
  "ccMetadata": {
    "ctnAssetsIssuer": "Catenis",
    "ctnAssetsDescription": "General purpose Catenis smart asset",
    "ctnAssetsLogoUrl": "https://catenis.io/logo/Catenis_small.png",  // URL to image file to be used as the logo image for all assets generated by Catenis
    "ctnAssetsLogoMimeType": "image/png",  // MIME type of image file to be used as the logo image for all assets generated by Catenis
    "ctnAssetsLogoHash": "dcde5882af4ee42617e5f9b1ff56d801be25c0c1af7ea8334eb46596616b15b2", // SHA256 hash of the logo image file
    "ctnAssetsLargeLogoUrl": "https://catenis.io/logo/Catenis_large.png", // URL to image file to be used as the large logo image for all assets generated by Catenis
    "ctnAssetsLargeLogoMimeType": "image/png",  // MIME type of image file to be used as the large logo image for all assets generated by Catenis
    "ctnAssetsLargeLogoHash": "0a5e3d326c0dfd1f87cebdd63fa214faebb9a3d48234a8c7352186985f838261", // SHA256 hash of the large logo image file
    "signingMessageFormat": "Catenis generated asset on %s",  // Format string used to compose message that is to be signed for asset verification purpose
    "signingCertificateFilePath": "/etc/letsencrypt/live/catenis.io/cert.pem",  // Path to file (in PEM format) containing Blockchain of Things' owned SSL certificate used to sign message for asset verification
    "signingCertificateKeyFilePath": "/etc/letsencrypt/live/catenis.io/privkey.pem",  // Path to file containing key of SSL certificate used to sign message for asset verification
    "urlContentTimeout": 15000,  // (15 sec.) Timeout, in milliseconds, for retrieving content associated with a given URL
    "encryptedUserDataKeyPrefix": "__enc_",  // Prefix that is prepended to user data key when its value is encrypted
    "shareAfterStoring": false  // Indicates whether metadata should be shared right after it is stored (added to Colored Coins metadata server)
  },
  // Parameters pertaining to CCTransaction module
  "ccTransaction": {
    "ccProtocolPrefix": "4343",  // Hex encoded (original) Colored Coins protocol data prefix
    "c3ProtocolPrefix": "4333",  // Hex encoded Catenis Colored Coins protocol data prefix
    "ccVersionByte": "02", // Hex encoded Colored Coins version byte
    "torrentHashSize": 20,  // Size, in number of bytes, of a torrent hash
    "sha2Size": 32  // Size, in number of bytes, of a SHA2 hash
  },
  // Parameters pertaining to CreditServiceAccTransaction module
  "creditServiceAccTransaction": {
    "maxNumCcTransferOutputs": 31,  //  Maximum number of Colored Coins transaction outputs that can exist in this transaction
    "safeNumCcTransferOutputs": 10,  // Maximum number of Colored Coins transaction outputs used to receive issued asset amount so it is guaranteed that encoded Colored Coins data will fit into transaction
    "ccMetadata": {
      "bcotPayTxidKey": "bcotPayTxid",  // Name (key) of Colored Coins free user metadata used to refer to BCOT Token Payment transaction
      "redeemBcotTxidKey": "redeemBcotTxid"  // Name (key) of Colored Coins free user metadata used to refer to Redeem BCOT transaction
    }
  },
  // Parameters pertaining to BcotToken module
  "bcotToken": {
    "bcotOmniPropertyId": 0,  // BCOT token Omni property ID (should be specifically defined for each environment)
    "storeBcotAddress": "????"  // Non-Catenis blockchain address to where BCOT tokens used in Catenis (either sent as payment or redeemed after purchase) should be stored
  },
  // Parameters pertaining to BcotPayment module
  "bcotPayment": {
    "usageReportHeaders": [  // List of names to be used as headers for the columns of the usage report
      "address",
      "amount",
      "txid",
      "confirmation_date"
    ]
  },
  // Parameters pertaining to StoreBcotTransaction module
  "storeBcotTransaction": {
    "timeToConfirm": 300  // (5 hours) Time, in minutes, that is expected the store BCOT transaction to be confirmed
  },
  // Parameters pertaining to SpendServiceCreditTransaction module
  "spendServiceCreditTransaction": {
    "maxNumClients": 12,  // Maximum number of clients that can be assigned to a single spend service credit transaction
    "ccMetadata": {
      "placeholder": {
        "key": "metaPlaceholder",
        "value": "Catenis Colored Coins metadata placeholder"
      },
      "servTxidsKey": "servTxids",  // Name (key) of Colored Coins free user metadata used to refer to service transaction
      "ocMsgServCidsKey": "ocMsgServCids"  // Name (key) of Colored Coins free user metadata used to refer to off-chain message related service data (off-chain message envelope)
    },
    "unconfirmedTxTimeout": 10080,  // (7 days) Timeout, in minutes, for waiting for latest sent spend service credit tx to be confirmed (set to 7 days, which is half the default mempool tx eviction time of 14 days)
    "txSizeThresholdRatio": 0.9  // Ratio that should be applied to maximum tx size to calculate threshold for spend service credit tx size. Above that size the tx fee rate should be reset so that is is confirmed as soon as possible
  },
  // Parameters pertaining to BcotUsageReportUI module
  "bcotUsageReportUI": {
    "baseFilename": "bcot_usage_report",  // Base name of the generated file containing the produced report
    "fileExtension": "csv",  // File extension to be used in the report filename
    "timeZones": [{
      "value": "local",
      "name": "Local time"
    }, {
      "value": "UTC",
      "name": "UTC"
    }, {
      "value": "US/PST",
      "name": "US/PST (UTC-08:00)"
    }, {
      "value": "US/MST",
      "name": "US/MST (UTC-07:00)"
    }, {
      "value": "US/CST",
      "name": "US/CST (UTC-06:00)"
    }, {
      "value": "US/EST",
      "name": "US/EST (UTC-05:00)"
    }, {
      "value": "Europe/GMT",
      "name": "Europe/GMT (UTC+00:00)"
    }, {
      "value": "Europe/WET",
      "name": "Europe - Portugal/WET (UTC+00:00)"
    }, {
      "value": "Europe/CET",
      "name": "Europe/CET (UTC+01:00)"
    }, {
      "value": "Europe/EET",
      "name": "Europe/EET (UTC+02:00)"
    }, {
      "value": "Europe/MSK",
      "name": "Europe - Russia/MSK (UTC+03:00)"
    }, {
      "value": "Asia/IST",
      "name": "Asia - India/IST (UTC+05:30)"
    }, {
      "value": "Asia/CST",
      "name": "Asia - China/CST (UTC+08:00)"
    }, {
      "value": "Asia/JST (UTC+09:00)",
      "name": "Asia - Japan/JST (UTC+09:00)"
    }],
    "defaultTimeZone": "UTC",  // Note: this should match the time zone setting in the BCOT Token app
    "includeHeaders": true  // Indicates whether report should include a first line with column headers
  },
  // Parameters pertaining to Asset module
  "asset": {
    "largestAssetAmount": 9007199254740991, // (2^53 - 1) Largest amount of assets (expressed in asset's smallest division) that can be issued
    "maxQueryIssuanceCount": 500,  // Maximum number of asset issuance entries that can be returned when retrieving asset issuance history
    "maxRetListEntries": 500  // Maximum number of entries that should be returned from asset related API methods that return a list of items (e.g. List Owned Assets, List Issued Assets, List Asset Holders)
  },
  // Parameters pertaining to EmailContents module
  "emailContents": {
    "resourcePath": "email/",  // Path (from private/ directory) from where e-mail contents resources (e.g. subject and body templates) should be loaded
    "subjectTemplateNameFormat": "%s_subject.txt",  // Format for composing file name of e-mail subject template
    "htmlBodyTemplateNameFormat": "%s_body.html",  // Format for composing file name of HTML version of e-mail body template
    "textBodyTemplateNameFormat": "%s_body.txt"  // Format for composing file name of text version of e-mail body template
  },
  // Parameters pertaining to AccountsEmail module
  "accountsEmail": {
    "fromAddress": "Catenis <noreply@blockchainofthings.com>",  // E-mail address used to send accounts related e-mail messages
    "resetPasswordContents": "PasswordReset",  // Name of e-mail contents used for password reset
    "enrollAccountContents": "AccountEnrollment",  // Name of e-mail contents used for account enrollment
    verifyEmailContents: "AccountRegVerifyEmail"  // Name of e-mail contents used for e-mail verification to complete account registration
  },
  // Parameters pertaining to ClientLicense module
  "clientLicense": {
    "defLateStartCompTimeThreshold": "12:00",  // Default late start compensation time threshold
    "daysToExpireForReminder": 15,  // Number of days from client license's expiration date that should trigger license expiration reminder notification e-mail message
    "licenseMonitorInterval": 15,  // Time interval, in minutes, used to monitor client licenses for update and expiration reminder.
                                   //  Note: this should be a divisor of an hour (60 min)
                                   //  Note 2: the rationale for using the value 15 is that existing time zone offsets are a whole number of hours, +00:300 or +00:45 from UTC
    "offSetToMonitor": 15000  // (15 sec.) Time, in milliseconds, that should be wait from the time set to start the monitoring of client licenses to actually start it
  },
  // Parameters pertaining to LicenseExpireEmailNotify module
  "licenseExpireEmailNotify": {
    "emailName": "LicenseExpiration",  // Reference name of e-mail contents to be used for this notification
    "fromAddress": "Catenis <noreply@blockchainofthings.com>",  // E-mail address of sender of e-mail notification message
    "replyAddress": "donotreply@blockchainofthings.com"  // (optional) E-mail address to be used as the address to be used when replying to notification e-mail message
  },
  // Parameters pertaining to LicenseOverdueEmailNotify module
  "licenseOverdueEmailNotify": {
    "emailName": "LicenseOverdue",  // Reference name of e-mail contents to be used for this notification
    "fromAddress": "Catenis <noreply@blockchainofthings.com>",  // E-mail address of sender of e-mail notification message
    "replyAddress": "donotreply@blockchainofthings.com"  // (optional) E-mail address to be used as the address to be used when replying to notification e-mail message
  },
  // Parameters pertaining to LicenseExpireRemindEmailNotify module
  "licenseExpireRemindEmailNotify": {
    "emailName": "LicenseExpirationReminder",  // Reference name of e-mail contents to be used for this notification
    "fromAddress": "Catenis <noreply@blockchainofthings.com>",  // E-mail address of sender of e-mail notification message
    "replyAddress": "donotreply@blockchainofthings.com"  // (optional) E-mail address to be used as the address to be used when replying to notification e-mail message
  },
  // Parameters pertaining to DevicesDisableEmailNotify module
  "devicesDisabledEmailNotify": {
    "emailName": "DevicesDisabled",  // Reference name of e-mail contents to be used for this notification
    "fromAddress": "Catenis <noreply@blockchainofthings.com>",  // E-mail address of sender of e-mail notification message
    "replyAddress": "donotreply@blockchainofthings.com"  // (optional) E-mail address to be used as the address to be used when replying to notification e-mail message
  },
  // Parameters pertaining to LowServAccBalanceEmailNotify module
  lowServAccBalanceEmailNotify: {
    emailName: "LowServAccBalance",  // Reference name of e-mail contents to be used for this notification
    fromAddress: "Catenis <noreply@blockchainofthings.com>",  // E-mail address of sender of e-mail notification message
    replyAddress: "donotreply@blockchainofthings.com",  // (optional) E-mail address to be used as the address to be used when replying to notification e-mail message
    onlineStoreUrl: "https://blockchainofthings.com/shop/"
  },
  // Parameters pertaining to AccountRegistrationEmailNotify module
  accountRegistrationEmailNotify: {
    emailName: "AccountRegistration",  // Reference name of e-mail contents to be used for this notification
    fromAddress: "Catenis <noreply@blockchainofthings.com>",  // E-mail address of sender of e-mail notification message
    replyAddress: "donotreply@blockchainofthings.com"  // (optional) E-mail address to be used as the address to be used when replying to notification e-mail message
  },
  // Parameters pertaining to BcotProduct module
  "bcotProduct": {
    "stdSkuFormat": "CTN-%s%s"  // (e.g. CTN-0000BCOT, for production) Format string to be used when generating standard BCOT product SKU
  },
  // Parameters pertaining to BcotSaleAllocation module
  "bcotSaleAllocation": {
    "allocatedProductsReport": {
      "baseFilename": "bcot_sale_alloc_prods",  // Base name of the generated file containing the produced report
      "fileExtension": "csv",  // File extension to be used in the report filename
      "headers": [  // List of names to be used as headers for the columns of the usage report
        "sku",
        "voucher_id"
      ]
    }
  },
  // Parameters pertaining to SelfRegistrationBcotSale module
  selfRegistrationBcotSale: {
    bcotProduct: null,  // (optional, can be set to null) SKU of BCOT product that should be used to be assigned to self-registered client accounts
    minAvailableQuantity: 0  // Minimum number of self-registration BCOT sale items that should be available (to be assigned to self-registered client accounts) at any time
  },
  // Parameters pertaining to RedeemBcotTransaction module
  "redeemBcotTransaction": {
    "timeToConfirm": 300  // (5 hours) Time, in minutes, that is expected the redeem BCOT token transaction to be confirmed
  },
  // Parameters pertaining to ProvisionalMessage module
  "provisionalMessage": {
    "timeContinueMsg": 300,  // (5 min.) Maximum time, in seconds, to wait until message continuation chunk is recorded
    "timeKeepIncompleteMsg": 3600,  // (1 hour) Minimum time, in seconds, to keep provisional messages that have not been finalized (a final chunk has never been recorded)
    "timeKeepProcessedMsg": 86400, // (24 hours) Minimum time, in seconds, to keep provisional messages after they have already been processed
    "purgeOldMessagesInterval": 43200000  // (12 hours) Time interval, in milliseconds, for executing method to purge old provisional messages
  },
  // Parameters pertaining to ProvisionalMessageReadable module
  "provisionalMessageReadable": {
    "highWaterMark": 1048576  // (1 MB) The maximum number of bytes to store in the internal buffer of stream before ceasing to read from the underlying resource
  },
  // Parameters pertaining to BufferMessageReadable module
  "bufferMessageReadable": {
    "highWaterMark": 1048576  // (1 MB) The maximum number of bytes to store in the internal buffer of stream before ceasing to read from the underlying resource
  },
  // Parameters pertaining to CachedMessage module
  "cachedMessage": {
    "timeContinueMsg": 300,  // (5 min.) Maximum time, in seconds, to wait until message continuation chunk is read
    "timeKeepIncompleteMsg": 3600,  // (1 hour) Minimum time, in seconds, to keep provisional messages that have not been finalized (a final chunk has never been recorded)
    "timeKeepUnreadMsg": 3600,  // (1 hour) Minimum time, in seconds, to keep cached messages that have not been fully read (not all of its data chunks read)
    "timeKeepReadMsg": 86400, // (24 hours) Minimum time, in seconds, to keep cached messages after they have been fully read (all of its data chunks read)
    "purgeOldMessagesInterval": 43200000  // (12 hours) Time interval, in milliseconds, for executing method to purge old cached messages
  },
  // Parameters pertaining to CachedMessageDuplex module
  "cachedMessageDuplex": {
    "highWaterMark": 1048576  // (1 MB) The maximum number of bytes to store in the internal buffer of stream before ceasing to read from the underlying resource
  },
  // Parameters pertaining to BufferMessageDuplex module
  "bufferMessageDuplex": {
    "highWaterMark": 1048576  // (1 MB) The maximum number of bytes to store in the internal buffer of stream before ceasing to read from the underlying resource
  },
  // Parameters pertaining to TwoFactorAuthentication module
  "twoFactorAuthentication": {
    "tokenValidationWindow": {
      "previous": 0,  // Number of previous time steps the tokens of which should still be considered valid
      "future": 0    // Number of future time steps the tokens of which should still be considered valid
    },
    "userVerificationInterval": 3600,  // (1 hour) Time, in seconds, within which it is expected that the user verifies a newly issued secret key
    "recoveryCode": {
      "codesToGenerate": 6,  // Number of recovery codes that should be generated at one time
      "length": 10,  // Length, in number of characters, that a recovery code should have
      "format": {
        "regexPattern": "([\\da-f]{5})([\\da-f]{5})",  // Regular expression pattern used to format the recovery codes
        "replaceStr": "$1-$2"  // The replacement string used to format the recovery codes
      },
      "usageNotifyEmail": {
        "fromAddress": "Catenis <noreply@blockchainofthings.com>",  // E-mail address used to send recovery code used notification e-mail
        "emailName": "TwoFactorAuthRecoveryCodeUsed"  // Name of e-mail contents used to notify of recovery code used
      }
    }
  },
  // Parameters pertaining to CatenisOffChainClient module
  catenisOffChainClient: {
    hostname: "localhost",
    port: 8199,
    connectTimeout: 5000,  // (5 sec.) Time, in milliseconds, to wait for a socket
    requestTimeout: 30000,  // (30 sec.) Time, in milliseconds, to wait for request to finish
    headersToSign: [
      "(request-target)",
      "Date",
      "Host"
    ]
  },
  // Parameters pertaining to CatenisOffChainNotification module
  catenisOffChainNotification: {
    connectTimeout: 5000,  // (5 sec.) Time, in milliseconds, to wait for a socket
    handshakeTimeout: 30000,  // (5 sec.) Time, in milliseconds, to wait for handshake request
    heartbeatPercentLag: 0.10,  // (10%) Percentage of server heartbeat time that client should wait for receiving ping packet
    heartbeatProbingCount: 6,  // Number of heartbeat cycles to use to measure heartbeat time
    defaultHeartbeatTimeout: 600000,  // (10 min.) Time, in milliseconds, to be used as heartbeat timeout before probing is done
    minReconnectTimeout: 10000,  // (10 sec.) Minimum time, in milliseconds, to wait before trying to reconnect
    maxReconnectTimeout: 600000,  // (10 min.) Minimum time, in milliseconds, to wait before trying to reconnect
    message: {
      newOffChainMsgData: 'NEW_OFF_CHAIN_MSG_DATA'
    }
  },
  // Parameters pertaining to OffChainMessagesSettlement module
  offChainMessagesSettlement: {
    refTimeZone: "UTC+00:00",  // Reference time zone expressed as a time difference from UTC (in the UTC+/-HH:mm format)
    startTime: "00:00:00",  // Time of day (formatted as HH[:mm[:ss[.SSS]]]), in reference to reference time zone, when settlement cycles should start
    cyclesPerDay: 4,  // Number of settlement cycles in a day (24 hour period). Note that a value less than one can be used to designate a period
                      //  (time between cycles) greater than 24 hours. In that case, the period shall be rounded to the nearest full hour
    maxCyclesToPostpone: 4  // Maximum settlement cycles that can be postponed before a settle off-chain messages transaction is sent when there not enough off-chain messages to pay for tx cost
  },
  // Parameters pertaining to CatenisOffChainMonitor module
  catenisOffChainMonitor: {
    autoPollingTimeInterval: 15000  // (15 sec.) Time, in milliseconds, of interval to automatically polling for Catenis off-chain message data
  },
  // Parameters pertaining to TransactionCache module
  transactionCache: {
    transactTTL: 604800000,  // (7 days) Time, in milliseconds, before cached transactions are considered aged
    ttlEvaluationInterval: 3600000  // (1 hour) Period of time, in milliseconds, when cached transactions' time-to-live is evaluated and aged cached transactions automatically removed
  },
  // Parameters pertaining to reCaptcha module
  reCaptcha: {
    verifyUrl: 'https://www.google.com/recaptcha/api/siteverify',  // URL of Web service used to verify the result of Google reCAPTCHA
    siteKey: '',  // (Public) Site key assigned to the Google reCAPTCHA account in use
    secretKey: '??????',  // Secret key assigned to the Google reCAPTCHA account in use
    useForLogin: true  // Indicates whether reCAPTCHA should be used when logging Catenis users in
  },
  // Parameters pertaining to PaidService module
  paidService: {
    refTimeZone: "UTC+00:00",  // Reference time zone expressed as a time difference from UTC (in the UTC+/-HH:mm format). Used to determine earliest date to keep history docs/recs
    daysToKeepHistory: 366,  // (1 (leap) year) Period of time, in days, that services cost history records should be kept. After that time, records are subject to being purged
    historyPurgeHours: 2,  // Hours component of time when purging of PaidServicesHistory database docs/recs should take place
    historyPurgeMinutes: 0,  // Minutes component of time when purging of PaidServicesHistory database docs/recs should take place
    historyPurgeSeconds: 0,  // Seconds component of time when purging of PaidServicesHistory database docs/recs should take place
    historyPurgeInterval: 86400000  // (24 hours) Time interval, in milliseconds, for executing process to purge old PaidServicesHistory database docs/recs
  },
  // Parameters pertaining to AdminEmailNotify module
  adminEmailNotify: {
    fromAddress: "Catenis <noreply@blockchainofthings.com>",  // E-mail address used to send notification e-mail messages to administrators
    replyAddress: "donotreply@blockchainofthings.com"  // (optional) E-mail address to be used as the address to be used when replying to notification e-mail message
  },
  // Parameters pertaining to ForeignBlockchain module
  foreignBlockchain: [
    {
      key: 'ethereum',
      name: 'Ethereum',
      classPrefix: 'Ethereum',
      nativeCoin: {
        name: 'ether',
        symbol: 'ETH'
      },
      blockTime: 15  // Theoretical block time (in seconds)
    },
    {
      key: 'binance',
      name: 'Binance Smart Chain',
      classPrefix: 'BinanceSC',
      nativeCoin: {
        name: 'Binance coin',
        symbol: 'BNB'
      },
      blockTime: 3  // Theoretical block time (in seconds)
    },
    {
      key: 'polygon',
      name: 'Polygon PoS Chain',
      classPrefix: 'PolygonPS',
      nativeCoin: {
        name: 'MATIC',
        symbol: 'MATIC'
      },
      blockTime: 2  // Theoretical block time (in seconds)
    }
  ],
  // Parameters pertaining to EthereumClient module
  ethereumClient: {
    nodeHost: '',  // Ethereum node client API hostname
    nodePath:  null,  // (optional, can be set to null) Ethereum node client API endpoint path
    nodePort: null,  // (optional, can be set to null) Ethereum node client API port. If null, the default port (8545) is used
    nodeProtocol: 'wss', // Ethereum node client API protocol. Expected values: 'http', 'https', 'ws' our 'wss'
    connectionOptions: {
      timeout: 15000,  // (15 sec.) Timeout (in milliseconds) after which a connection/request will fail
      http: {
        keepAlive: true
      },
      webSocket: {
        heartbeatInterval: 30000,  // (30 sec.) (optional, can be set to null) Time interval (in milliseconds) for sending ping to server to indicate that client is still alive
        reconnect: {
          auto: false,  // Indicates whether reconnection should be automatically attempted
          delay: 500,  // (0.5 sec.) Timeout (in milliseconds) to try to reconnect
          maxAttempts: 1,  // (optional, can be set to null) Maximum reconnection attempts, after which an error is issued
          onTimeout: true   // Try to reconnect after a connection/request timeout
        }
      }
    },
    apiUsername: '??????',  // (optional, can be set to null) Base64 encoded, ciphered username for accessing Ethereum node client API
    apiPassword: '??????',  // (optional, can be set to null) Base64 encoded, ciphered password for accessing Ethereum node client API
    web3Settings: {
      txBlockTimeout: 50  // (number of blocks) 'transactionBlockTimeout' setting for web3.js client library (used for WebSocket connections)
    }
  },
  // Parameters pertaining to BinanceSCClient module
  binanceSCClient: {
    nodeHost: '',  // Binance Smart Chain node client API hostname
    nodePath:  null,  // (optional, can be set to null) Binance Smart Chain node client API endpoint path
    nodePort: null,  // (optional, can be set to null) Binance Smart Chain node client API port. If null, the default port (8545) is used
    nodeProtocol: 'wss', // Binance Smart Chain node client API protocol. Expected values: 'http', 'https', 'ws' our 'wss'
    connectionOptions: {
      timeout: 15000,  // (15 sec.) Timeout (in milliseconds) after which a connection/request will fail
      http: {
        keepAlive: true
      },
      webSocket: {
        heartbeatInterval: 30000,  // (30 sec.) (optional, can be set to null) Time interval (in milliseconds) for sending ping to server to indicate that client is still alive
        reconnect: {
          auto: false,  // Indicates whether reconnection should be automatically attempted
          delay: 500,  // (0.5 sec.) Timeout (in milliseconds) to try to reconnect
          maxAttempts: 1,  // (optional, can be set to null) Maximum reconnection attempts, after which an error is issued
          onTimeout: true   // Try to reconnect after a connection/request timeout
        }
      }
    },
    apiUsername: '??????',  // (optional, can be set to null) Base64 encoded, ciphered username for accessing Binance Smart Chain node client API
    apiPassword: '??????',  // (optional, can be set to null) Base64 encoded, ciphered password for accessing Binance Smart Chain node client API
    web3Settings: {
      txBlockTimeout: 50  // (number of blocks) 'transactionBlockTimeout' setting for web3.js client library (used for WebSocket connections)
    }
  },
  // Parameters pertaining to PolygonPSClient module
  polygonPSClient: {
    nodeHost: '',  // Polygon PoS Chain node client API hostname
    nodePath:  null,  // (optional, can be set to null) Polygon PoS Chain node client API endpoint path
    nodePort: null,  // (optional, can be set to null) Polygon PoS Chain node client API port. If null, the default port (8545) is used
    nodeProtocol: 'wss', // Polygon PoS Chain node client API protocol. Expected values: 'http', 'https', 'ws' our 'wss'
    connectionOptions: {
      timeout: 15000,  // (15 sec.) Timeout (in milliseconds) after which a connection/request will fail
      http: {
        keepAlive: true
      },
      webSocket: {
        heartbeatInterval: 30000,  // (30 sec.) (optional, can be set to null) Time interval (in milliseconds) for sending ping to server to indicate that client is still alive
        reconnect: {
          auto: false,  // Indicates whether reconnection should be automatically attempted
          delay: 500,  // (0.5 sec.) Timeout (in milliseconds) to try to reconnect
          maxAttempts: 1,  // (optional, can be set to null) Maximum reconnection attempts, after which an error is issued
          onTimeout: true   // Try to reconnect after a connection/request timeout
        }
      }
    },
    apiUsername: '??????',  // (optional, can be set to null) Base64 encoded, ciphered username for accessing Polygon PoS Chain node client API
    apiPassword: '??????',  // (optional, can be set to null) Base64 encoded, ciphered password for accessing Polygon PoS Chain node client API
    web3Settings: {
      txBlockTimeout: 50  // (number of blocks) 'transactionBlockTimeout' setting for web3.js client library (used for WebSocket connections)
    }
  },
  // Parameters pertaining to ForeignSmartContract module
  foreignSmartContract: {
    updateNonceMaxRetries: 10  // Maximum number of retries for sending transaction with an updated nonce
  },
  // Parameters pertaining to CatenisErc20Token module
  catenisErc20Token: {
    resourcePath: 'asset_export/ethereum/',  // Path (from private/ directory) from where associated Ethereum contract compilation output should be loaded
    compiledOutputFilename: 'CatenisERC20Token.json',  // Filename of Ethereum contract compilation output
    updateNonceMaxRetries: 10  // Maximum number of retries for sending transaction with an updated nonce
  },
  // Parameters pertaining to EthereumGasPrices module
  ethereumGasPrices: {
    apiUrl: "https://api.blocknative.com/",  // Blocknative API URL
    blockPricesEndPoint: "gasprices/blockprices",  // API endpoint for retrieving Ethereum gas price estimates
    localAddress: null,  // (optional, can be set to null) IP address of local network interface to use to issue requests to the Web service
    timeout: 20000,  // (20 sec.) Timeout, in milliseconds, for connection/request with API server
    apiKey: '??????',  // Base64 encoded, ciphered Blocknative API key used for service authentication
    confidenceLevels: [  // List indicating the price estimates that should be returned for different probabilities for making to the next block
      99,                //  Each value must be a percentage (1-99), and the list can have no more than 5 values
      95,
      90,
      80,
      70
    ]
  },
  // Parameters pertaining to BinanceSCGasPrices module
  binanceSCGasPrices: {
    apiUrl: "https://owlracle.info/",  // Owlracle multichain gas price tracker API URL
    gasPricesEndPoint: "bsc/gas",  // API endpoint for retrieving Binance Smart Chain gas price estimates
    version: 2,  // The Owlracle API version to use
    localAddress: null,  // (optional, can be set to null) IP address of local network interface to use to issue requests to the Web service
    timeout: 20000,  // (20 sec.) Timeout, in milliseconds, for connection/request with API server
    apiKey: '??????',  // (optional, can be set to null) Base64 encoded, ciphered Owlracle API key used for getting extended service (more free requests)
    acceptances: [  // List indicating the price estimate that should be returned for different probabilities for making to the next block
      100,
      90,
      60,
      35
    ]
  },
  // Parameters pertaining to PolygonPSGasPrices module
  polygonPSGasPrices: {
    apiUrl: "https://gasstation-mainnet.matic.network/",  // Matic (Polygon) Gas Station API URL
    gasPricesEndPoint: "",  // API endpoint for retrieving Polygon PoS Chain gas price estimates
    localAddress: null,  // (optional, can be set to null) IP address of local network interface to use to issue requests to the Web service
    timeout: 20000  // (20 sec.) Timeout, in milliseconds, for connection/request with API server
  },
  // Parameters pertaining to ExportedAsset module
  exportedAsset: {
    checkPendingExportRetryInterval: 300000,  // (5 sec.) Time interval, in milliseconds, for retrying check for pending exported asset
    reprocessFailedTxReceipts: {
      tickInterval: 300000,  // (5 sec.) Time interval, in milliseconds, equivalent to a reprocessing tick
      ticksToReprocessFactor: 2,  // Factor used for calculating the next value for the ticks to reprocess according
                                  //  to the following formula: ticks = ratio ^ (reprocessCounter - 1)
      maxTicksToReprocess: 1024,  // Maximum value for the ticks to reprocess
      maxReprocessCounter: 10  // Maximum times for reprocessing failed tx receipt (and try again to retrieve tx receipt)
    },
    checkOldPendingTxInterval: 1800000,  // (30 min.) Time interval, in milliseconds, for checking if there are old foreign blockchain transactions that are still pending
    oldPendingTxTimeFactor: 2,  // Multiplication factor (over web3.js' tx pooling timeout) for defining time to considering a pending foreign blockchain transactions as old
    txExecEventsTimeoutFactor: 1.5,  // Multiplication factor (over web3.js' tx pooling timeout) for defining the timeout for waiting for foreign blockchain transaction execution outcome events
    maxQueryCount: 500  // Maximum number of entries that can be returned when querying for exported assets
  },
  // Parameters pertaining to AssetMigration module
  assetMigration: {
    checkPendingMigrationRetryInterval: 300000,  // (5 sec.) Time interval, in milliseconds, for retrying check for pending asset migration
    reprocessFailedTxReceipts: {
      tickInterval: 300000,  // (5 sec.) Time interval, in milliseconds, equivalent to a reprocessing tick
      ticksToReprocessFactor: 2,  // Factor used for calculating the next value for the ticks to reprocess according
                                  //  to the following formula: ticks = ratio ^ (reprocessCounter - 1)
      maxTicksToReprocess: 1024,  // Maximum value for the ticks to reprocess
      maxReprocessCounter: 10  // Maximum times for reprocessing failed tx receipt (and try again to retrieve tx receipt)
    },
    checkOldPendingTxInterval: 1800000,  // (30 min.) Time interval, in milliseconds, for checking if there are old foreign blockchain transactions that are still pending
    oldPendingTxTimeFactor: 2,  // Multiplication factor (over web3.js' tx pooling timeout) for defining time to considering a pending foreign blockchain transactions as old
    txExecEventsTimeoutFactor: 1.5,  // Multiplication factor (over web3.js' tx pooling timeout) for defining the timeout for waiting for foreign blockchain transaction execution outcome events
    maxQueryCount: 500  // Maximum number of entries that can be returned when querying for asset migrations
  },
  // Parameters pertaining to AccountRegistration module
  accountRegistration: {
    clientName: 'Self-registered ({!username})',  // Name to be assigned to client account for self-registered users
    license: {   // Client license to be used for a self-registration account
      level: "Starter",
      type: null,  // Note: may be set to null to specify a license with no type
      revision: 0
    }
  },
  // Parameters pertaining to CrmIntegration module
  crmIntegration: {
    formUrl: 'https://crm.zoho.com/crm/WebToLeadForm',  // URL of the form used to pass customer data to the Blockchain of Things CRM system.
                                                        //  Note: set to null to disable passing customer data
    localAddress: null,  // (optional, can be set to null) IP address of local network interface to use when issuing requests
    timeout: 20000,  // (20 sec.) Timeout, in milliseconds, for connection/request
    fields: [{
      name: 'xnQsjsdp',
      value: '71b0e32d89d616853fc65c92845db906105cf6a82bd120670b6c7c1eb0487d5d',
      mappedClientProp: null
    }, {
      name: 'zc_gad',
      value: '',
      mappedClientProp: null
    }, {
      name: 'xmIwtLD',
      value: '3da7098ca28176d6d6260345406b639fbb4bc058a692090944c280f9bb37e962',
      mappedClientProp: null
    }, {
      name: 'actionType',
      value: 'TGVhZHM=',
      mappedClientProp: null
    }, {
      name: 'returnURL',
      value: 'https://www.blockchainofthings.com/exclude/success',
      mappedClientProp: null
    }, {
      name: 'First Name',
      value: null,
      mappedClientProp: 'props.firstName'
    }, {
      name: 'Last Name',
      value: null,
      mappedClientProp: 'props.lastName'
    }, {
      name: 'Email',
      value: null,
      mappedClientProp: 'userAccountEmail'
    }, {
      name: 'Phone',
      value: null,
      mappedClientProp: 'props.phone'
    }, {
      name: 'Company',
      value: null,
      mappedClientProp: 'props.company'
    }, {
      name: 'Lead Source',
      value: 'Starter',
      mappedClientProp: null
    }]
  },
  // Parameters pertaining to UINotification module
  uiNotification: {
    refTimeZone: "UTC+00:00",  // Reference time zone expressed as a time difference from UTC (in the UTC+/-HH:mm format). Used to determine the notification's expiration date
    fromAddress: "Catenis <noreply@blockchainofthings.com>",  // E-mail address used to send UI notification e-mail messages to Catenis users
    replyAddress: "donotreply@blockchainofthings.com",  // (optional) E-mail address to be used when replying to UI notification e-mail messages
    emailHtmlTemplate: "<style>{!stylesheet}div.ctn_uiNotificationEmail p {margin-top:0;margin-bottom:0}div.ctn_uiNotificationEmail div.ctn_uiNotificationEmailSalutation p {margin-bottom:1.5em}div.ctn_uiNotificationEmail div.ctn_uiNotificationEmailSignature p {margin-top:1.5em}</style><div class=\"ctn_uiNotificationEmail ctn-uiNotificationStyles\"><div class=\"ctn_uiNotificationEmailSalutation\">{!salutation}</div>{!body}<div class=\"ctn_uiNotificationEmailSignature\">{!signature}</div></div>",
    emailTextTemplate: "{!salutation}\n{!body}\n{!signature}",
    messageExcerpt: {
      numTextLines: 2,
      textLineLength: 120,
    }
  },
  // Parameters pertaining to UserUINotification module
  userUINotification: {
    displayBatchSize: 50  // Number of notification messages that should be fetched at time to be displayed on the UI
  },
  // Parameters pertaining to Bip32 module
  bip32: {
    eccLibProxyReadyTimeout: 10000  // (10 sec) Timeout, in milliseconds, for waiting for ECC library proxy object to be ready for use
  },
  // Parameters pertaining to BtcPrice module
  eccLibraryProxy: {
    inspectPort: 9229  // TCP port used to connect debugger to RestApi child processes
  },
  // Parameters pertaining to IpcRpc modules
  ipcRpc: {
    rpcCallTimeout: 30000  // Timeout, in millisecond, for waiting on return from RPC command executed on child process
  },
  // Parameters pertaining to modules of different child processes
  childProcess: {
    nodeJSExec: null, // Path of Node.js executable used to run child processes. If not defined or null, same version as main process is used
    // Parameters pertaining to EccLibrary child process modules
    eccLibraryProcess: {
      // Parameters pertaining to EccLibraryMain module of EccLibrary child process
      eccLibraryMain: {
        ipcMessageCommand: {
          init: "init",  // Process initialization command
          eccLibraryMethods: [  // Commands for executing an ECC library method
            "isPoint",                  // ECC library isPoint() method
            "isPointCompressed",        // ECC library isPointCompressed() method
            "isXOnlyPoint",             // ECC library isXOnlyPoint() method
            "isPrivate",                // ECC library isPrivate() method
            "pointAdd",                 // ECC library pointAdd() method
            "pointAddScalar",           // ECC library pointAddScalar() method
            "pointCompress",            // ECC library pointCompress() method
            "pointFromScalar",          // ECC library pointFromScalar() method
            "xOnlyPointFromScalar",     // ECC library xOnlyPointFromScalar() method
            "xOnlyPointFromPoint",      // ECC library xOnlyPointFromPoint() method
            "pointMultiply",            // ECC library pointMultiply() method
            "privateAdd",               // ECC library privateAdd() method
            "privateSub",               // ECC library privateSub() method
            "XOnlyPointAddTweakResult", // ECC library XOnlyPointAddTweakResult() method
            "xOnlyPointAddTweak",       // ECC library xOnlyPointAddTweak() method
            "xOnlyPointAddTweakCheck",  // ECC library xOnlyPointAddTweakCheck() method
            "sign",                     // ECC library sign() method
            "signSchnorr",              // ECC library signSchnorr() method
            "verify",                   // ECC library verify() method
            "verifySchnorr"             // ECC library verifySchnorr() method
          ],
        }
      }
    }
  }
}